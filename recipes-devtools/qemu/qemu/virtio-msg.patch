Upstream-Status: Inappropriate work in progress
diff --git a/docs/devel/virtio-msg.rst b/docs/devel/virtio-msg.rst
new file mode 100644
index 0000000000..e69f8e3f44
--- /dev/null
+++ b/docs/devel/virtio-msg.rst
@@ -0,0 +1 @@
+This file has moved into docs/devel/virtio-msg/virtio-msg.rst
diff --git a/docs/devel/virtio-msg/dts/Makefile b/docs/devel/virtio-msg/dts/Makefile
new file mode 100644
index 0000000000..adba484ccb
--- /dev/null
+++ b/docs/devel/virtio-msg/dts/Makefile
@@ -0,0 +1,5 @@
+xen.dtb: xen.dts overlay.dtsi
+	dtc -I dts -O dtb -o $@ $<
+
+clean:
+	$(RM) xen.dtb
diff --git a/docs/devel/virtio-msg/dts/overlay.dtsi b/docs/devel/virtio-msg/dts/overlay.dtsi
new file mode 100644
index 0000000000..1801d3b7bd
--- /dev/null
+++ b/docs/devel/virtio-msg/dts/overlay.dtsi
@@ -0,0 +1,33 @@
+/ {
+	/*
+        shm@23f000000 {
+                compatible = "mmio-sram";
+                xen,passthrough;
+                reg = <0x2 0x3f000000 0x0 0x01000000>;
+        };
+*/
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		linux,initrd-start = <0x50000000>;
+		linux,initrd-end = <0x54000000>;
+
+		stdout-path = "/pl011@9000000";
+		kaslr-seed = <0xd68ecccf 0x8bdd7e5a>;
+		bootargs = "rdinit=/bin/sh console=ttyAMA0,115200n8 earlyprintk=serial,ttyAMA0";
+		xen,xen-bootargs = "dom0_mem=2G bootscrub=0";
+		xen,dom0-bootargs = "rw root=/dev/ram rdinit=/sbin/init earlyprintk=serial,ttyAMA0 console=hvc0 earlycon=xenboot";
+
+		module@0 {
+			compatible = "xen,linux-zimage", "xen,multiboot-module";
+			reg = <0x47000000 0x29a1a00>;
+			bootargs = "rw root=/dev/ram rdinit=/sbin/init earlyprintk=serial,ttyAMA0 console=hvc0 earlycon=xenboot";
+		};
+
+		module@1 {
+			compatible = "xen,linux-initrd", "xen,multiboot-module";
+			reg = <0x50000000 0x8000000>;
+		};
+	};
+};
diff --git a/docs/devel/virtio-msg/dts/xen.dts b/docs/devel/virtio-msg/dts/xen.dts
new file mode 100644
index 0000000000..d35ef914d0
--- /dev/null
+++ b/docs/devel/virtio-msg/dts/xen.dts
@@ -0,0 +1,397 @@
+/dts-v1/;
+
+/ {
+	interrupt-parent = <0x8003>;
+	model = "linux,dummy-virt";
+	#size-cells = <0x02>;
+	#address-cells = <0x02>;
+	compatible = "linux,dummy-virt";
+
+	psci {
+		migrate = <0xc4000005>;
+		cpu_on = <0xc4000003>;
+		cpu_off = <0x84000002>;
+		cpu_suspend = <0xc4000001>;
+		method = "smc";
+		compatible = "arm,psci-1.0\0arm,psci-0.2\0arm,psci";
+	};
+
+	memory@40000000 {
+                reg = <0x0 0x40000000 0x1 0xff>;
+		//reg = <0x00 0x40000000 0x02 0x00>;
+		device_type = "memory";
+	};
+
+	platform-bus@c000000 {
+		interrupt-parent = <0x8003>;
+		ranges = <0x00 0x00 0xc000000 0x2000000>;
+		#address-cells = <0x01>;
+		#size-cells = <0x01>;
+		compatible = "qemu,platform\0simple-bus";
+	};
+
+	fw-cfg@9020000 {
+		dma-coherent;
+		reg = <0x00 0x9020000 0x00 0x18>;
+		compatible = "qemu,fw-cfg-mmio";
+	};
+
+	virtio_mmio@a000000 {
+		dma-coherent;
+		interrupts = <0x00 0x10 0x01>;
+		reg = <0x00 0xa000000 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a000200 {
+		dma-coherent;
+		interrupts = <0x00 0x11 0x01>;
+		reg = <0x00 0xa000200 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a000400 {
+		dma-coherent;
+		interrupts = <0x00 0x12 0x01>;
+		reg = <0x00 0xa000400 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a000600 {
+		dma-coherent;
+		interrupts = <0x00 0x13 0x01>;
+		reg = <0x00 0xa000600 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a000800 {
+		dma-coherent;
+		interrupts = <0x00 0x14 0x01>;
+		reg = <0x00 0xa000800 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a000a00 {
+		dma-coherent;
+		interrupts = <0x00 0x15 0x01>;
+		reg = <0x00 0xa000a00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a000c00 {
+		dma-coherent;
+		interrupts = <0x00 0x16 0x01>;
+		reg = <0x00 0xa000c00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a000e00 {
+		dma-coherent;
+		interrupts = <0x00 0x17 0x01>;
+		reg = <0x00 0xa000e00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a001000 {
+		dma-coherent;
+		interrupts = <0x00 0x18 0x01>;
+		reg = <0x00 0xa001000 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a001200 {
+		dma-coherent;
+		interrupts = <0x00 0x19 0x01>;
+		reg = <0x00 0xa001200 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a001400 {
+		dma-coherent;
+		interrupts = <0x00 0x1a 0x01>;
+		reg = <0x00 0xa001400 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a001600 {
+		dma-coherent;
+		interrupts = <0x00 0x1b 0x01>;
+		reg = <0x00 0xa001600 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a001800 {
+		dma-coherent;
+		interrupts = <0x00 0x1c 0x01>;
+		reg = <0x00 0xa001800 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a001a00 {
+		dma-coherent;
+		interrupts = <0x00 0x1d 0x01>;
+		reg = <0x00 0xa001a00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a001c00 {
+		dma-coherent;
+		interrupts = <0x00 0x1e 0x01>;
+		reg = <0x00 0xa001c00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a001e00 {
+		dma-coherent;
+		interrupts = <0x00 0x1f 0x01>;
+		reg = <0x00 0xa001e00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a002000 {
+		dma-coherent;
+		interrupts = <0x00 0x20 0x01>;
+		reg = <0x00 0xa002000 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a002200 {
+		dma-coherent;
+		interrupts = <0x00 0x21 0x01>;
+		reg = <0x00 0xa002200 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a002400 {
+		dma-coherent;
+		interrupts = <0x00 0x22 0x01>;
+		reg = <0x00 0xa002400 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a002600 {
+		dma-coherent;
+		interrupts = <0x00 0x23 0x01>;
+		reg = <0x00 0xa002600 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a002800 {
+		dma-coherent;
+		interrupts = <0x00 0x24 0x01>;
+		reg = <0x00 0xa002800 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a002a00 {
+		dma-coherent;
+		interrupts = <0x00 0x25 0x01>;
+		reg = <0x00 0xa002a00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a002c00 {
+		dma-coherent;
+		interrupts = <0x00 0x26 0x01>;
+		reg = <0x00 0xa002c00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a002e00 {
+		dma-coherent;
+		interrupts = <0x00 0x27 0x01>;
+		reg = <0x00 0xa002e00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a003000 {
+		dma-coherent;
+		interrupts = <0x00 0x28 0x01>;
+		reg = <0x00 0xa003000 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a003200 {
+		dma-coherent;
+		interrupts = <0x00 0x29 0x01>;
+		reg = <0x00 0xa003200 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a003400 {
+		dma-coherent;
+		interrupts = <0x00 0x2a 0x01>;
+		reg = <0x00 0xa003400 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a003600 {
+		dma-coherent;
+		interrupts = <0x00 0x2b 0x01>;
+		reg = <0x00 0xa003600 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a003800 {
+		dma-coherent;
+		interrupts = <0x00 0x2c 0x01>;
+		reg = <0x00 0xa003800 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a003a00 {
+		dma-coherent;
+		interrupts = <0x00 0x2d 0x01>;
+		reg = <0x00 0xa003a00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a003c00 {
+		dma-coherent;
+		interrupts = <0x00 0x2e 0x01>;
+		reg = <0x00 0xa003c00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@a003e00 {
+		dma-coherent;
+		interrupts = <0x00 0x2f 0x01>;
+		reg = <0x00 0xa003e00 0x00 0x200>;
+		compatible = "virtio,mmio";
+	};
+
+	smmuv3@9050000 {
+		phandle = <0x8005>;
+		#iommu-cells = <0x01>;
+		dma-coherent;
+		interrupt-names = "eventq\0priq\0cmdq-sync\0gerror";
+		interrupts = <0x00 0x4a 0x01 0x00 0x4b 0x01 0x00 0x4c 0x01 0x00 0x4d 0x01>;
+		reg = <0x00 0x9050000 0x00 0x20000>;
+		compatible = "arm,smmu-v3";
+	};
+
+	pcie@10000000 {
+		iommu-map = <0x00 0x8005 0x00 0x10000>;
+		interrupt-map-mask = <0x1800 0x00 0x00 0x07>;
+		interrupt-map = <0x00 0x00 0x00 0x01 0x8003 0x00 0x00 0x00 0x03 0x04 0x00 0x00 0x00 0x02 0x8003 0x00 0x00 0x00 0x04 0x04 0x00 0x00 0x00 0x03 0x8003 0x00 0x00 0x00 0x05 0x04 0x00 0x00 0x00 0x04 0x8003 0x00 0x00 0x00 0x06 0x04 0x800 0x00 0x00 0x01 0x8003 0x00 0x00 0x00 0x04 0x04 0x800 0x00 0x00 0x02 0x8003 0x00 0x00 0x00 0x05 0x04 0x800 0x00 0x00 0x03 0x8003 0x00 0x00 0x00 0x06 0x04 0x800 0x00 0x00 0x04 0x8003 0x00 0x00 0x00 0x03 0x04 0x1000 0x00 0x00 0x01 0x8003 0x00 0x00 0x00 0x05 0x04 0x1000 0x00 0x00 0x02 0x8003 0x00 0x00 0x00 0x06 0x04 0x1000 0x00 0x00 0x03 0x8003 0x00 0x00 0x00 0x03 0x04 0x1000 0x00 0x00 0x04 0x8003 0x00 0x00 0x00 0x04 0x04 0x1800 0x00 0x00 0x01 0x8003 0x00 0x00 0x00 0x06 0x04 0x1800 0x00 0x00 0x02 0x8003 0x00 0x00 0x00 0x03 0x04 0x1800 0x00 0x00 0x03 0x8003 0x00 0x00 0x00 0x04 0x04 0x1800 0x00 0x00 0x04 0x8003 0x00 0x00 0x00 0x05 0x04>;
+		#interrupt-cells = <0x01>;
+		ranges = <0x1000000 0x00 0x00 0x00 0x3eff0000 0x00 0x10000 0x2000000 0x00 0x10000000 0x00 0x10000000 0x00 0x2eff0000 0x3000000 0x80 0x00 0x80 0x00 0x80 0x00>;
+		reg = <0x40 0x10000000 0x00 0x10000000>;
+		msi-map = <0x00 0x8004 0x00 0x10000>;
+		dma-coherent;
+		bus-range = <0x00 0xff>;
+		linux,pci-domain = <0x00>;
+		#size-cells = <0x02>;
+		#address-cells = <0x03>;
+		device_type = "pci";
+		compatible = "pci-host-ecam-generic";
+	};
+
+	pl031@9010000 {
+		clock-names = "apb_pclk";
+		clocks = <0x8000>;
+		interrupts = <0x00 0x02 0x04>;
+		reg = <0x00 0x9010000 0x00 0x1000>;
+		compatible = "arm,pl031\0arm,primecell";
+	};
+
+	pl011@9000000 {
+		clock-names = "uartclk\0apb_pclk";
+		clocks = <0x8000 0x8000>;
+		interrupts = <0x00 0x01 0x04>;
+		reg = <0x00 0x9000000 0x00 0x1000>;
+		compatible = "arm,pl011\0arm,primecell";
+	};
+
+	pmu {
+		interrupts = <0x01 0x07 0x04>;
+		compatible = "arm,armv8-pmuv3";
+	};
+
+	intc@8000000 {
+		phandle = <0x8003>;
+		interrupts = <0x01 0x09 0x04>;
+		reg = <0x00 0x8000000 0x00 0x10000 0x00 0x80a0000 0x00 0xf60000>;
+		#redistributor-regions = <0x01>;
+		compatible = "arm,gic-v3";
+		ranges;
+		#size-cells = <0x02>;
+		#address-cells = <0x02>;
+		interrupt-controller;
+		#interrupt-cells = <0x03>;
+
+		its@8080000 {
+			phandle = <0x8004>;
+			reg = <0x00 0x8080000 0x00 0x20000>;
+			#msi-cells = <0x01>;
+			msi-controller;
+			compatible = "arm,gic-v3-its";
+		};
+	};
+
+	flash@0 {
+		bank-width = <0x04>;
+		reg = <0x00 0x00 0x00 0x4000000 0x00 0x4000000 0x00 0x4000000>;
+		compatible = "cfi-flash";
+	};
+
+	cpus {
+		#size-cells = <0x00>;
+		#address-cells = <0x01>;
+
+		cpu-map {
+
+			socket0 {
+
+				cluster0 {
+
+					core0 {
+						cpu = <0x8002>;
+					};
+
+					core1 {
+						cpu = <0x8001>;
+					};
+				};
+			};
+		};
+
+		cpu@0 {
+			phandle = <0x8002>;
+			reg = <0x00>;
+			enable-method = "psci";
+			compatible = "arm,cortex-a57";
+			device_type = "cpu";
+		};
+
+		cpu@1 {
+			phandle = <0x8001>;
+			reg = <0x01>;
+			enable-method = "psci";
+			compatible = "arm,cortex-a57";
+			device_type = "cpu";
+		};
+	};
+
+	timer {
+		interrupts = <0x01 0x0d 0x04 0x01 0x0e 0x04 0x01 0x0b 0x04 0x01 0x0a 0x04>;
+		always-on;
+		compatible = "arm,armv8-timer\0arm,armv7-timer";
+	};
+
+	apb-pclk {
+		phandle = <0x8000>;
+		clock-output-names = "clk24mhz";
+		clock-frequency = <0x16e3600>;
+		#clock-cells = <0x00>;
+		compatible = "fixed-clock";
+	};
+
+	chosen {
+		stdout-path = "/pl011@9000000";
+		rng-seed = <0x6189e5b8 0x66c9d2d6 0xf62b2e0c 0x19a21a66 0xfc809969 0xd539496b 0xe8726bb0 0x9a7db1bf>;
+		kaslr-seed = <0x7b58bea 0x7490a7ee>;
+	};
+};
+
+/include/ "overlay.dtsi"
diff --git a/docs/devel/virtio-msg/guest-virtio-msg.cfg b/docs/devel/virtio-msg/guest-virtio-msg.cfg
new file mode 100644
index 0000000000..68d16a6476
--- /dev/null
+++ b/docs/devel/virtio-msg/guest-virtio-msg.cfg
@@ -0,0 +1,13 @@
+name = "g0"
+memory = 1152
+vcpus = 1
+kernel = "Image"
+ramdisk = "core-image-minimal-qemuarm64.rootfs.cpio.gz"
+extra = "root=/dev/ram0 console=ttyAMA0"
+device_model_version = "qemu-xen"
+device_model_override = "/usr/bin/qemu-system-aarch64"
+device_model_args = [ '-device', 'virtio-msg-proxy-driver,virtio-id=0x1', '-device', 'virtio-msg-bus-ivshmem,dev=0000:00:02.0,iommu=xen-gfn2mfn,remote-vmid=0x1C']
+virtio = [ "type=virtio,device, transport=mmio, grant_usage=0" ]
+#vif = [ 'model=virtio-net,type=ioemu,bridge=xenbr0' ]
+# Dummy disk to for xen-tools to launch a QEMU.
+disk = [ '/etc/xen/file.img,,xvda,backendtype=qdisk,specification=virtio' ]
diff --git a/docs/devel/virtio-msg/scripts/guest-qemu-run-msg.sh b/docs/devel/virtio-msg/scripts/guest-qemu-run-msg.sh
new file mode 100755
index 0000000000..ee3b163d5c
--- /dev/null
+++ b/docs/devel/virtio-msg/scripts/guest-qemu-run-msg.sh
@@ -0,0 +1,23 @@
+#!/bin/sh
+
+#MACHINE="-M virt,memory-backend=foo.ram"
+QEMU=qemu-system-aarch64
+MACHINE="-M x-virtio-msg"
+VMID=$1
+shift 1
+
+DEV_DOORBELL=0000:00:02.0
+DEV_SYSMEM=0000:00:03.0
+
+MEMFILE=/sys/bus/pci/devices/${DEV_SYSMEM}/resource2_wc
+
+set -x
+${QEMU} ${MACHINE} -m 4G             \
+        -object memory-backend-file,id=mem,size=4G,mem-path=${MEMFILE},share=on \
+        -serial mon:stdio -display none                         \
+	-device virtio-msg-bus-ivshmem,dev=${DEV_DOORBELL},remote-vmid=${VMID},memdev=mem,mem-offset=0x40000000,reset-queues=true \
+        -device virtio-net-device,mq=on,netdev=net0,iommu_platform=on           \
+        -netdev user,id=net0                                                    \
+        "$@"
+
+exit 0
diff --git a/docs/devel/virtio-msg/scripts/guest-qemu-run-virt.sh b/docs/devel/virtio-msg/scripts/guest-qemu-run-virt.sh
new file mode 100755
index 0000000000..8c2d71d355
--- /dev/null
+++ b/docs/devel/virtio-msg/scripts/guest-qemu-run-virt.sh
@@ -0,0 +1,23 @@
+#!/bin/sh
+
+#MACHINE="-M virt,memory-backend=foo.ram"
+QEMU=qemu-system-aarch64
+MACHINE="-M virt"
+KERNEL=${HOME}/Image
+ROOTFS=${HOME}/core-image-minimal-qemuarm64.rootfs.cpio.gz
+
+DEV_DOORBELL=0000:00:02.0
+
+set -x
+${QEMU} ${MACHINE} -m 2G -cpu host -accel kvm                   \
+        -serial mon:stdio -display none                             \
+        -kernel ${KERNEL}                                       \
+        -initrd ${ROOTFS}                                       \
+        -append "rdinit=/sbin/init console=ttyAMA0 lpj=100"     \
+        -device virtio-msg-proxy-driver-pci,virtio-id=0x1 \
+        -device virtio-msg-bus-ivshmem,dev=${DEV_DOORBELL},iommu=linux-proc-pagemap,remote-vmid=0x1C   \
+        "$@"
+
+exit 0
+
+
diff --git a/docs/devel/virtio-msg/scripts/run-A.sh b/docs/devel/virtio-msg/scripts/run-A.sh
new file mode 100755
index 0000000000..800479cd43
--- /dev/null
+++ b/docs/devel/virtio-msg/scripts/run-A.sh
@@ -0,0 +1,65 @@
+#!/bin/sh
+
+QEMU=${HOME}/src/c/qemu/build-qemu/qemu-system-aarch64
+#QEMU=${HOME}/xilinx/build-qemu/qemu-system-aarch64
+XEN=hyp/xen/xen/xen
+#XEN=yocto/yoxen/build/tmp/deploy/images/qemuarm64/xen-qemuarm64
+#KERNEL=yocto/yoxen/build/tmp/deploy/images/qemuarm64/Image
+KERNEL=/home/edgar/src/c/linux/linux/arch/arm64/boot/Image
+UBOOT=u-boot/u-boot.bin
+DTB=dts/xen.dtb
+#DTB=dts/virt-gicv2.dtb
+#ROOTFS=yocto/yoxen/build/tmp/deploy/images/qemuarm64/xen-image-minimal-qemuarm64.rootfs.cpio.gz
+ROOTFS=yocto/yoxen/build/tmp/deploy/images/qemuarm64/core-image-minimal-qemuarm64.rootfs.cpio.gz
+
+echo booti 0x42000000 - 0x44000000
+echo booti 0x47000000 - 0x44000000
+
+set -x
+
+${QEMU} -machine virt,gic_version=3,iommu=smmuv3 \
+	-machine virtualization=true \
+	-object memory-backend-file,id=vm0_mem,size=4G,mem-path=/dev/shm/qemu-xen-vm0-ram,share=on \
+	-object memory-backend-file,id=vm1_mem,size=4G,mem-path=/dev/shm/qemu-xen-vm1-ram,share=on \
+	-machine memory-backend=vm0_mem \
+	-cpu cortex-a57 -machine type=virt -m 4G -smp 2 \
+	-bios ${UBOOT} \
+	-device loader,file=${XEN},force-raw=on,addr=0x42000000 \
+	-device loader,file=${KERNEL},addr=0x47000000 \
+	-device loader,file=${DTB},addr=0x44000000 \
+	-device loader,file=${ROOTFS},force-raw=on,addr=0x50000000 \
+	-device loader,file=${KERNEL},addr=0x60000000 \
+	-device loader,file=${ROOTFS},force-raw=on,addr=0x70000000 \
+	-nographic -no-reboot \
+	-device virtio-net-pci,netdev=net0,romfile="" \
+	-netdev type=user,id=net0,hostfwd=tcp::2222-:22,hostfwd=tcp::2223-10.0.2.16:22 \
+	-device ivshmem-doorbell,vectors=2,chardev=ivsh \
+	-chardev socket,path=shmpath,id=ivsh \
+	-device ivshmem-plain,memdev=vm1_mem \
+	$*
+
+exit 0
+
+#	-device ivshmem-doorbell,memdev=hostmem \
+#	-object memory-backend-file,size=1M,share=on,mem-path=/dev/shm/ivshmem,id=hostmem \
+
+#	-device virtio-net-device,netdev=net0 \
+#	-device virtio-net-pci,netdev=net0,romfile="" \
+#	-device loader,file=${ROOTFS},addr=0x50000000 \
+#	-device loader,file=${KERNEL},addr=0x60000000 \
+#	-device loader,file=${ROOTFS},addr=0x70000000 \
+
+# Coverage
+# -d nochain -etrace elog -etrace-flags exec -accel tcg,thread=single
+
+#	-bios ${UBOOT} \
+#	-device loader,file=${XEN},force-raw=on,addr=0x42000000 \
+#	-device loader,file=${KERNEL},addr=0x47000000 \
+#	-device loader,file=${DTB},addr=0x44000000 \
+
+#	-kernel ${KERNEL} \
+#	-initrd ${ROOTFS} \
+#	-append "rdinit=/sbin/init console=ttyAMA0,115200n8 earlyprintk=serial,ttyAMA0" \
+
+#	-d int,guest_errors,exec -D log \
+#
diff --git a/docs/devel/virtio-msg/scripts/run-B.sh b/docs/devel/virtio-msg/scripts/run-B.sh
new file mode 100755
index 0000000000..094139abac
--- /dev/null
+++ b/docs/devel/virtio-msg/scripts/run-B.sh
@@ -0,0 +1,61 @@
+#!/bin/sh
+
+QEMU=${HOME}/src/c/qemu/build-qemu/qemu-system-aarch64
+#QEMU=${HOME}/xilinx/build-qemu/qemu-system-aarch64
+XEN=hyp/xen/xen/xen
+#XEN=yocto/yoxen/build/tmp/deploy/images/qemuarm64/xen-qemuarm64
+#KERNEL=yocto/yoxen/build/tmp/deploy/images/qemuarm64/Image
+KERNEL=/home/edgar/src/c/linux/linux/arch/arm64/boot/Image
+UBOOT=u-boot/u-boot.bin
+DTB=dts/xen.dtb
+ROOTFS=yocto/yoxen/build/tmp/deploy/images/qemuarm64/core-image-minimal-qemuarm64.rootfs.cpio.gz
+
+echo booti 0x42000000 - 0x44000000
+echo booti 0x47000000 - 0x44000000
+
+set -x
+
+${QEMU} -machine virt,gic_version=3,iommu=smmuv3 \
+	-machine virtualization=true \
+	-object memory-backend-file,id=vm0_mem,size=4G,mem-path=/dev/shm/qemu-xen-vm0-ram,share=on \
+	-object memory-backend-file,id=vm1_mem,size=4G,mem-path=/dev/shm/qemu-xen-vm1-ram,share=on \
+	-machine memory-backend=vm1_mem \
+	-cpu cortex-a57 -machine type=virt -m 4G -smp 2 \
+	-bios ${UBOOT} \
+	-device loader,file=${XEN},force-raw=on,addr=0x42000000 \
+	-device loader,file=${KERNEL},addr=0x47000000 \
+	-device loader,file=${DTB},addr=0x44000000 \
+	-device loader,file=${ROOTFS},force-raw=on,addr=0x50000000 \
+	-device loader,file=${KERNEL},addr=0x60000000 \
+	-device loader,file=${ROOTFS},force-raw=on,addr=0x70000000 \
+	-nographic -no-reboot \
+	-device virtio-net-pci,netdev=net0,romfile="" \
+	-netdev type=user,id=net0,hostfwd=tcp::2224-:22,hostfwd=tcp::2225-10.0.2.16:22 \
+	-device ivshmem-doorbell,vectors=2,chardev=ivsh \
+	-chardev socket,path=shmpath,id=ivsh \
+	-device ivshmem-plain,memdev=vm0_mem \
+	$*
+
+#	-device ivshmem-doorbell,memdev=hostmem \
+#	-object memory-backend-file,size=1M,share=on,mem-path=/dev/shm/ivshmem,id=hostmem \
+
+#	-device virtio-net-device,netdev=net0 \
+#	-device virtio-net-pci,netdev=net0,romfile="" \
+#	-device loader,file=${ROOTFS},addr=0x50000000 \
+#	-device loader,file=${KERNEL},addr=0x60000000 \
+#	-device loader,file=${ROOTFS},addr=0x70000000 \
+
+# Coverage
+# -d nochain -etrace elog -etrace-flags exec -accel tcg,thread=single
+
+#	-bios ${UBOOT} \
+#	-device loader,file=${XEN},force-raw=on,addr=0x42000000 \
+#	-device loader,file=${KERNEL},addr=0x47000000 \
+#	-device loader,file=${DTB},addr=0x44000000 \
+
+#	-kernel ${KERNEL} \
+#	-initrd ${ROOTFS} \
+#	-append "rdinit=/sbin/init console=ttyAMA0,115200n8 earlyprintk=serial,ttyAMA0" \
+
+#	-d int,guest_errors,exec -D log \
+#
diff --git a/docs/devel/virtio-msg/virtio-msg.rst b/docs/devel/virtio-msg/virtio-msg.rst
new file mode 100644
index 0000000000..0fe6fdc224
--- /dev/null
+++ b/docs/devel/virtio-msg/virtio-msg.rst
@@ -0,0 +1,224 @@
+..
+
+VirtIO-MSG
+==========
+
+Virtio-msg is a new message based virtio transport (as opposed to memory
+access based ones). It is comparable to virtio-ccw and to some extent
+vhost-user.
+
+QEMU has an implementation of the virtio-msg transport aswell as an
+implementation of a proxy that translates between existing transport
+(e.g virtio-mmio/pci) and virtio-msg.
+
+At a high level the virtio-msg spec is split into the message transport and
+the lower level message bus. Different implementations of msg busses are
+expected, e.g FF-A, direct hw (vfio?), Linux user-space, Xen and others.
+
+Currently we have a PoC of a Linux userspace bus that allows communication
+between QEMU's running on the same host. We also have a vfio based bus
+driver that works over two ivshmem devices in separate QEMU instances.
+
+The msg-bus abstraction is implemented here:
+  hw/virtio/virtio-msg-bus.c
+
+The linux-user message-bus implementation here:
+  hw/virtio/virtio-msg-bus-linux-user.c
+  include/hw/virtio/spsc_queue.h
+
+The ivshmem message-bus implementation here:
+  hw/virtio/virtio-msg-bus-ivshmem.c
+  include/hw/virtio/spsc_queue.h
+
+The virtio-msg protocol packetizer/decoder here:
+  include/hw/virtio/virtio-msg-prot.h
+
+The transport:
+  hw/virtio/virtio-msg.c
+
+The proxy device that translates from mmio/pci to msg:
+  hw/virtio/virtio-msg-proxy-driver.c
+
+The virtio-msg backend machine:
+  hw/virtio/virtio-msg-machine.c
+
+Running Virtio-MSG with the Linux-user msg-bus using two QEMU instances
+-----------------------------------------------------------------------
+
+To run this example you first need to run the virtio-msg machine and
+secondly then the virt machine with Linux.
+
+Running the virtio-msg backends machine:
+
+Before running the virtio-msg machine with the backends, we need to
+remove any existing queue's.
+
+.. code-block:: bash
+
+   rm -fr queue-linux-user-d* && \
+   qemu-system-aarch64 -M x-virtio-msg -m 2G -cpu cortex-a72 \
+        -object memory-backend-file,id=mem,size=2G,mem-path=/dev/shm/qemu-ram,share=on \
+        -machine memory-backend=mem \
+        -chardev socket,id=chr0,path=linux-user.socket,server=on,wait=false \
+        -serial mon:stdio -display none \
+        -device virtio-msg-bus-linux-user,name=linux-user,chardev=chr0,memdev=mem,mem-offset=0x40000000 \
+        -device virtio-net-device,netdev=net0,iommu_platform=on \
+        -netdev user,id=net0 \
+        -object filter-dump,id=f0,netdev=net0,file=net.pcap
+
+
+Running a Linux guest on the virt machine:
+
+.. code-block:: bash
+
+   qemu-system-aarch64 -M virt -m 2G -cpu cortex-a72 \
+        -object memory-backend-file,id=mem,size=2G,mem-path=/dev/shm/qemu-ram,share=on \
+        -machine memory-backend=mem \
+        -chardev socket,id=chr0,path=linux-user.socket \
+        -serial mon:stdio -display none \
+        -kernel Image \
+        -initrd core-image-minimal-qemuarm64.rootfs.cpio.gz \
+        -append "rdinit=/sbin/init console=ttyAMA0 lpj=100" \
+        -device virtio-msg-proxy-driver-pci,virtio-id=0x1 \
+        -device virtio-msg-bus-linux-user,name=linux-user,chardev=chr0
+
+
+To use virtio-mmio, replace the -device virtio-msg-proxy-driver-pci with:
+
+.. code-block:: bash
+
+   -device virtio-msg-proxy-driver,iommu_platform=on,virtio-id=0x1      \
+   -global virtio-mmio.force-legacy=false                               \
+
+
+Running Virtio-MSG over the IVSHMEM msg-bus using two QEMU instances
+--------------------------------------------------------------------
+
+We'll run two outer QEMU instances that emulate our HW. These will
+use a memory backend of shared files for the machine system memory.
+In addition to that, the same memory backend will be used for
+IVSHMEM devices on each QEMU instance. This will allow both
+instances to access all of each others system memory via the IVSHMEM
+devices BAR.
+
+I've tried 2 different setups, one runs virtio-msg between a driver
+KVM guest and a Xen dom0 with the backends. The second setup is
+between two Xen instances and their respective dom0s. In theory,
+KVM to KVM and Xen DomU to DomU or any combination should work.
+
+
+First, we need to start the ivshmem server. Here shmpath is the name
+of a unix socket that we'll need to connect to later on.
+
+.. code-block:: bash
+
+   rm shmpath
+   ivshmem-server -S shmpath -p pidfile -l 1M -n 1
+
+
+
+I've added some example scripts in docs/devel/virtio-msg/scripts/.
+run-A.sh and run-B.sh are used to run the outer QEMU's for system
+A and B.
+
+You'll need to change some paths in the script to match your environment.
+QEMU points to your build of QEMU from the edgar/virtio-msg branch.
+XEN points to your build of Xen from the edgar/virtio-msg branch.
+
+https://github.com/edgarigl/xen/tree/edgar/virtio-msg
+
+KERNEL points to a build of a Linux kernel (upstream)
+UBOOT points to a build of U-boot from upstream
+DTB points to a device-tree file for the QEMU virt machine.
+
+To create the DTB, you can start by running the QEMU command-line from
+below, remove the line that loads the non-existing DTB, and add
+-machine dumpdtb=virt.dtb. Convert that to a dts and edit it to add
+the appropriate nodes for Xen (xen,bootargs, dom0 image etc).
+I've provided an example in docs/devel/virtio-msg/dts/
+
+Run Xen or Linux/KVM on QEMU for ARM:
+
+.. code-block:: bash
+
+   run-A.sh
+
+Once you get into U-boot, you can boot Xen by doing the following:
+
+.. code-block:: bash
+
+   booti 0x42000000 - 0x44000000
+
+
+Or boot KVM by doing the following:
+
+.. code-block:: bash
+
+   booti 0x47000000 - 0x44000000
+
+
+Once you've booted two instances of either Xen or KVM, we need to prep
+the IVSHMEM PCIe devices to be used for notifications. You'll need to do
+these steps on both machines.
+
+Enable VFIO (including noiommu for Xen) for IVSHMEM:
+.. code-block:: bash
+
+    echo 1 >/sys/module/vfio/parameters/enable_unsafe_noiommu_mode
+    echo 1af4 1110 >/sys/bus/pci/drivers/vfio-pci/new_id
+
+
+Figure out the IVSHMEM VMID. Find the IVSHMEM device by running lspci -v,
+it will be the IVSHMEM device with 3 BARs, e.g:
+
+.. code-block:: bash
+
+   lspci -v
+   00:02.0 RAM memory: Red Hat, Inc. Inter-VM shared memory (rev 01)
+        Subsystem: Red Hat, Inc. QEMU Virtual Machine
+        Flags: fast devsel, IRQ 24, IOMMU group 1
+        Memory at 10001000 (32-bit, non-prefetchable) [size=4K]
+        Memory at 10002000 (32-bit, non-prefetchable) [size=4K]
+        Memory at 8100000000 (64-bit, prefetchable) [size=1M]
+        Capabilities: [40] MSI-X: Enable- Count=2 Masked-
+        Kernel driver in use: vfio-pci
+
+
+The VMID can be read from BAR0 offset 8:
+
+.. code-block:: bash
+
+    devmem2 0x10001008 w
+    /dev/mem opened.
+    Memory mapped at address 0xffff8b8ef000.
+    Read at address  0x10001008 (0xffff8b8ef008): 0x0000002E
+
+
+In our example, the VMID was 0x2E. Remember, you'll need to figure out the
+VMID's for both outer QEMU machines.
+
+To run the inner QEMU's with virtio-msg support, I've provided a couple of
+examples in docs/devel/virtio-msg/scripts/. There's guest-qemu-run-msg.sh that
+runs the device/backend side. You'll need to edit the script to match where your IVSHMEM devices ended up. The script takes the VMID of the other outer QEMU as an argument.
+
+.. code-block:: bash
+
+   ./guest-qemu-run-msg.sh 0x2e
+
+
+To a guest in KVM, edit and run the guest-qemu-run-virt.sh script.
+You'll need to update the remote-vmid property with the VMID of the QEMU machine running the backends.
+
+.. code-block:: bash
+
+   ./guest-qemu-run-virt.sh
+
+
+You should now see Linux booting in the inner VM.
+
+If you want to run a DomU in Xen instead of a KVM guest, I've provided an example guest-virtio-msg.cfg. You'll have to edit it for IVSHMEM device ID and remote-vmid.
+
+.. code-block:: bash
+
+   xl create -cd guest-virtio-msg.cfg
+
diff --git a/hw/misc/ivshmem.c b/hw/misc/ivshmem.c
index 0447888029..a7a7777b0d 100644
--- a/hw/misc/ivshmem.c
+++ b/hw/misc/ivshmem.c
@@ -47,7 +47,7 @@
 #define IVSHMEM_IOEVENTFD   0
 #define IVSHMEM_MSI     1
 
-#define IVSHMEM_REG_BAR_SIZE 0x100
+#define IVSHMEM_REG_BAR_SIZE 0x1000
 
 #define IVSHMEM_DEBUG 0
 #define IVSHMEM_DPRINTF(fmt, ...)                       \
@@ -140,9 +140,11 @@ static inline bool ivshmem_is_master(IVShmemState *s)
 
 static void ivshmem_IntrMask_write(IVShmemState *s, uint32_t val)
 {
+    PCIDevice *pdev = PCI_DEVICE(s);
     IVSHMEM_DPRINTF("IntrMask write(w) val = 0x%04x\n", val);
 
     s->intrmask = val;
+    pci_set_irq(pdev, !!(s->intrstatus & s->intrmask));
 }
 
 static uint32_t ivshmem_IntrMask_read(IVShmemState *s)
@@ -155,17 +157,21 @@ static uint32_t ivshmem_IntrMask_read(IVShmemState *s)
 
 static void ivshmem_IntrStatus_write(IVShmemState *s, uint32_t val)
 {
+    PCIDevice *pdev = PCI_DEVICE(s);
     IVSHMEM_DPRINTF("IntrStatus write(w) val = 0x%04x\n", val);
 
     s->intrstatus = val;
+    pci_set_irq(pdev, !!(s->intrstatus & s->intrmask));
 }
 
 static uint32_t ivshmem_IntrStatus_read(IVShmemState *s)
 {
+    PCIDevice *pdev = PCI_DEVICE(s);
     uint32_t ret = s->intrstatus;
 
     /* reading ISR clears all interrupts */
     s->intrstatus = 0;
+    pci_set_irq(pdev, !!(s->intrstatus & s->intrmask));
     return ret;
 }
 
@@ -266,6 +272,8 @@ static void ivshmem_vector_notify(void *opaque)
     if (ivshmem_has_feature(s, IVSHMEM_MSI)) {
         if (msix_enabled(pdev)) {
             msix_notify(pdev, vector);
+        } else {
+            ivshmem_IntrStatus_write(s, 1);
         }
     } else {
         ivshmem_IntrStatus_write(s, 1);
@@ -848,6 +856,9 @@ static void ivshmem_common_realize(PCIDevice *dev, Error **errp)
     pci_conf = dev->config;
     pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;
 
+    /* Enable Legacy INTX.  */
+    pci_config_set_interrupt_pin(pci_conf, 1);
+
     memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,
                           "ivshmem-mmio", IVSHMEM_REG_BAR_SIZE);
 
diff --git a/hw/virtio/meson.build b/hw/virtio/meson.build
index c0055a7832..3c6c5df540 100644
--- a/hw/virtio/meson.build
+++ b/hw/virtio/meson.build
@@ -10,6 +10,20 @@ system_virtio_ss.add(when: 'CONFIG_VHOST_VDPA_DEV', if_true: files('vdpa-dev.c')
 specific_virtio_ss = ss.source_set()
 specific_virtio_ss.add(files('virtio.c'))
 specific_virtio_ss.add(files('virtio-config-io.c', 'virtio-qmp.c'))
+specific_virtio_ss.add(files('virtio-msg-machine.c'))
+specific_virtio_ss.add(files('virtio-msg-bus.c'))
+specific_virtio_ss.add(files('virtio-msg-bus-linux-user.c'))
+specific_virtio_ss.add(files('virtio-msg-bus-ivshmem.c'))
+specific_virtio_ss.add(files('virtio-msg-bus-sapphire.c'))
+specific_virtio_ss.add(files('virtio-msg-bus-vek280-hexcam.c'))
+specific_virtio_ss.add(files('virtio-msg-proxy-driver.c'))
+specific_virtio_ss.add(files('virtio-msg.c'))
+
+specific_virtio_ss.add(when: ['CONFIG_XEN', xen], if_true: files(
+    'virtio-msg-bus-xen.c',
+))
+
+system_virtio_ss.add(when: 'CONFIG_VIRTIO_PCI', if_true: files('virtio-msg-proxy-driver-pci.c'))
 
 if have_vhost
   system_virtio_ss.add(files('vhost.c'))
diff --git a/hw/virtio/virtio-config-io.c b/hw/virtio/virtio-config-io.c
index ad78e0b9bc..f0945e4ea9 100644
--- a/hw/virtio/virtio-config-io.c
+++ b/hw/virtio/virtio-config-io.c
@@ -18,6 +18,10 @@ uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint8_t val;
 
+    if (k->read_config) {
+        return k->read_config(vdev, sizeof val, addr);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return (uint32_t)-1;
     }
@@ -33,6 +37,10 @@ uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint16_t val;
 
+    if (k->read_config) {
+        return k->read_config(vdev, sizeof val, addr);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return (uint32_t)-1;
     }
@@ -48,6 +56,10 @@ uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint32_t val;
 
+    if (k->read_config) {
+        return k->read_config(vdev, sizeof val, addr);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return (uint32_t)-1;
     }
@@ -63,6 +75,10 @@ void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint8_t val = data;
 
+    if (k->write_config) {
+        return k->write_config(vdev, sizeof val, addr, val);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return;
     }
@@ -79,6 +95,10 @@ void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint16_t val = data;
 
+    if (k->write_config) {
+        return k->write_config(vdev, sizeof val, addr, val);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return;
     }
@@ -95,6 +115,10 @@ void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint32_t val = data;
 
+    if (k->write_config) {
+        return k->write_config(vdev, sizeof val, addr, val);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return;
     }
@@ -111,6 +135,10 @@ uint32_t virtio_config_modern_readb(VirtIODevice *vdev, uint32_t addr)
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint8_t val;
 
+    if (k->read_config) {
+        return k->read_config(vdev, sizeof val, addr);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return (uint32_t)-1;
     }
@@ -126,6 +154,10 @@ uint32_t virtio_config_modern_readw(VirtIODevice *vdev, uint32_t addr)
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint16_t val;
 
+    if (k->read_config) {
+        return k->read_config(vdev, sizeof val, addr);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return (uint32_t)-1;
     }
@@ -141,6 +173,10 @@ uint32_t virtio_config_modern_readl(VirtIODevice *vdev, uint32_t addr)
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint32_t val;
 
+    if (k->read_config) {
+        return k->read_config(vdev, sizeof val, addr);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return (uint32_t)-1;
     }
@@ -157,6 +193,10 @@ void virtio_config_modern_writeb(VirtIODevice *vdev,
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint8_t val = data;
 
+    if (k->write_config) {
+        return k->write_config(vdev, sizeof val, addr, val);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return;
     }
@@ -174,6 +214,10 @@ void virtio_config_modern_writew(VirtIODevice *vdev,
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint16_t val = data;
 
+    if (k->write_config) {
+        return k->write_config(vdev, sizeof val, addr, val);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return;
     }
@@ -191,6 +235,10 @@ void virtio_config_modern_writel(VirtIODevice *vdev,
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint32_t val = data;
 
+    if (k->write_config) {
+        return k->write_config(vdev, sizeof val, addr, val);
+    }
+
     if (addr + sizeof(val) > vdev->config_len) {
         return;
     }
diff --git a/hw/virtio/virtio-mmio.c b/hw/virtio/virtio-mmio.c
index 22f15e1e02..2ee46ffe4f 100644
--- a/hw/virtio/virtio-mmio.c
+++ b/hw/virtio/virtio-mmio.c
@@ -402,6 +402,7 @@ static void virtio_mmio_write(void *opaque, hwaddr offset, uint64_t value,
                 ((uint64_t)proxy->vqs[vdev->queue_sel].used[1]) << 32 |
                 proxy->vqs[vdev->queue_sel].used[0]);
             proxy->vqs[vdev->queue_sel].enabled = 1;
+            virtio_queue_enable(vdev, vdev->queue_sel);
         } else {
             proxy->vqs[vdev->queue_sel].enabled = 0;
         }
diff --git a/hw/virtio/virtio-msg-bus-ivshmem.c b/hw/virtio/virtio-msg-bus-ivshmem.c
new file mode 100644
index 0000000000..b8ffebc7a8
--- /dev/null
+++ b/hw/virtio/virtio-msg-bus-ivshmem.c
@@ -0,0 +1,287 @@
+/*
+ * VirtIO MSG bus over IVSHMEM devices.
+ * This uses switchboards underlying queue's (mmap) to transfer message.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include <linux/vfio.h>
+#include "qemu/units.h"
+#include "qemu/event_notifier.h"
+#include "qemu/main-loop.h"
+#include "qapi/error.h"
+#include "hw/qdev-properties.h"
+#include "hw/qdev-properties-system.h"
+
+#include "hw/virtio/virtio-msg-bus-ivshmem.h"
+
+#define IVD_BAR0_INTR_MASK    0x0
+#define IVD_BAR0_INTR_STATUS  0x4
+#define IVD_BAR0_IV_POSITION  0x8
+#define IVD_BAR0_DOORBELL     0xc
+
+static inline void ivshmem_write32(void *p, uint32_t val) {
+        intptr_t addr = (intptr_t) p;
+
+        assert((addr % sizeof val) == 0);
+        *(volatile uint32_t *)p = val;
+}
+
+static inline uint32_t ivshmem_read32(void *p) {
+        intptr_t addr = (intptr_t) p;
+        uint32_t val;
+
+        assert((addr % sizeof val) == 0);
+        val = *(volatile uint32_t *)p;
+        return val;
+}
+
+static void virtio_msg_bus_ivshmem_send_notify(VirtIOMSGBusIVSHMEM *s)
+{
+    ivshmem_write32(s->msg.doorbell + IVD_BAR0_DOORBELL,
+                    s->cfg.remote_vmid << 16);
+}
+
+static AddressSpace *virtio_msg_bus_ivshmem_get_remote_as(VirtIOMSGBusDevice *bd)
+{
+    VirtIOMSGBusIVSHMEM *s = VIRTIO_MSG_BUS_IVSHMEM(bd);
+
+    if (!s->cfg.memdev) {
+        return NULL;
+    }
+    return &s->as;
+}
+
+static void virtio_msg_bus_ivshmem_process(VirtIOMSGBusDevice *bd) {
+    VirtIOMSGBusIVSHMEM *s = VIRTIO_MSG_BUS_IVSHMEM(bd);
+    spsc_queue *q;
+    VirtIOMSG msg;
+    bool r;
+
+    /*
+     * We process the opposite queue, i.e, a driver will want to receive
+     * messages on the backend queue (and send messages on the driver queue).
+     */
+    q = bd->peer->is_driver ? s->shm_queues.device : s->shm_queues.driver;
+    do {
+        r = spsc_recv(q, &msg, sizeof msg);
+        if (r) {
+            virtio_msg_bus_receive(bd, &msg);
+        }
+    } while (r);
+}
+
+static void ivshmem_intx_interrupt(void *opaque)
+{
+    VirtIOMSGBusIVSHMEM *s = VIRTIO_MSG_BUS_IVSHMEM(opaque);
+    VirtIOMSGBusDevice *bd = VIRTIO_MSG_BUS_DEVICE(opaque);
+
+    if (!event_notifier_test_and_clear(&s->notifier)) {
+        return;
+    }
+
+    /* ACK the interrupt.  */
+    ivshmem_read32(s->msg.doorbell + IVD_BAR0_INTR_STATUS);
+    virtio_msg_bus_process(bd);
+    qemu_vfio_pci_unmask_irq(s->msg.dev, VFIO_PCI_INTX_IRQ_INDEX);
+}
+
+static int virtio_msg_bus_ivshmem_send(VirtIOMSGBusDevice *bd, VirtIOMSG *msg_req,
+                                          VirtIOMSG *msg_resp)
+{
+    VirtIOMSGBusIVSHMEM *s = VIRTIO_MSG_BUS_IVSHMEM(bd);
+    spsc_queue *q_tx;
+    spsc_queue *q_rx;
+    bool sent;
+    int i;
+
+    q_tx = bd->peer->is_driver ? s->shm_queues.driver : s->shm_queues.device;
+    q_rx = bd->peer->is_driver ? s->shm_queues.device : s->shm_queues.driver;
+
+    do {
+        sent = spsc_send(q_tx, msg_req, sizeof *msg_req);
+    } while (!sent);
+
+    virtio_msg_bus_ivshmem_send_notify(s);
+
+    if (msg_resp) {
+        bool r = false;
+
+        for (i = 0; !r && i < 1024; i++){
+            r = spsc_recv(q_rx, msg_resp, sizeof *msg_resp);
+
+            if (!r) {
+                /* No message available, keep going with some delay.  */
+                if (i > 128) {
+                    usleep(i / 128);
+                }
+            }
+
+            if (r && !virtio_msg_is_resp(msg_req, msg_resp)) {
+                /* Let the virtio-msg stack handle this.  */
+                virtio_msg_bus_ooo_receive(bd, msg_req, msg_resp);
+                /* Keep going.  */
+                r = 0;
+            }
+        }
+        if (!r) {
+            /*
+             * FIXME: Devices/backends need to be able to recover from
+             * errors like this. Think a QEMU instance serving multiple
+             * guests via multiple virtio-msg devs. Can't allow one of
+             * them to bring down the entire QEMU.
+             */
+            printf("ERROR: %s: timed out!!\n", __func__);
+            abort();
+        }
+
+        /*
+         * We've got our response. Unpack it and return back to the caller.
+         */
+        virtio_msg_unpack(msg_resp);
+    }
+
+    return VIRTIO_MSG_NO_ERROR;
+}
+
+static void virtio_msg_bus_ivshmem_realize(DeviceState *dev, Error **errp)
+{
+    VirtIOMSGBusIVSHMEM *s = VIRTIO_MSG_BUS_IVSHMEM(dev);
+    VirtIOMSGBusDevice *bd = VIRTIO_MSG_BUS_DEVICE(dev);
+    VirtIOMSGBusDeviceClass *bdc = VIRTIO_MSG_BUS_DEVICE_GET_CLASS(dev);
+    uint64_t mem_size;
+    int ret;
+
+    bdc->parent_realize(dev, errp);
+    if (*errp) {
+        return;
+    }
+
+    if (s->cfg.dev == NULL) {
+        error_setg(errp, "property 'dev' not specified.");
+        return;
+    }
+
+    ret = event_notifier_init(&s->notifier, 0);
+    if (ret) {
+        error_setg(errp, "Failed to init event notifier");
+        return;
+    }
+
+    if (s->cfg.iommu) {
+        if (!strcmp(s->cfg.iommu, "xen-gfn2mfn")) {
+            bd->iommu_translate = virtio_msg_bus_xen_gfn2mfn_translate;
+        } else if (!strcmp(s->cfg.iommu, "linux-proc-pagemap")) {
+            bd->iommu_translate = virtio_msg_bus_pagemap_translate;
+        }
+    }
+
+    s->msg.dev = qemu_vfio_open_pci(s->cfg.dev, &error_fatal);
+
+    s->msg.doorbell = qemu_vfio_pci_map_bar(s->msg.dev, 0, 0, 4 * KiB,
+                                            PROT_READ | PROT_WRITE,
+                                            &error_fatal);
+
+    s->msg.driver = qemu_vfio_pci_map_bar(s->msg.dev, 2, 0, 4 * KiB,
+                                          PROT_READ | PROT_WRITE,
+                                          &error_fatal);
+    s->msg.device = qemu_vfio_pci_map_bar(s->msg.dev, 2, 4 * KiB, 4 * KiB,
+                                          PROT_READ | PROT_WRITE,
+                                          &error_fatal);
+
+    qemu_vfio_pci_init_irq(s->msg.dev, &s->notifier,
+                           VFIO_PCI_INTX_IRQ_INDEX, &error_fatal);
+
+    qemu_set_fd_handler(event_notifier_get_fd(&s->notifier),
+                        ivshmem_intx_interrupt, NULL, s);
+
+    if (s->cfg.reset_queues) {
+        memset(s->msg.driver, 0, 4 * KiB);
+        memset(s->msg.device, 0, 4 * KiB);
+    }
+
+    s->shm_queues.driver = spsc_open_mem("queue-driver",
+                                         spsc_capacity(4 * KiB), s->msg.driver);
+    s->shm_queues.device = spsc_open_mem("queue-device",
+                                         spsc_capacity(4 * KiB), s->msg.device);
+
+    /* Unmask interrupts.  */
+    ivshmem_write32(s->msg.doorbell + IVD_BAR0_INTR_MASK, 0xffffffff);
+
+    if (s->cfg.memdev == NULL) {
+        /* No memory mappings needed.  */
+        return;
+    }
+
+    s->mr_memdev = host_memory_backend_get_memory(s->cfg.memdev);
+    memory_region_init(&s->mr, OBJECT(s), "mr", UINT64_MAX);
+
+    mem_size = memory_region_size(s->mr_memdev);
+    if (s->cfg.mem_hole > 0) {
+        uint64_t lowmem_end = s->cfg.mem_offset + s->cfg.mem_low_size;
+        uint64_t highmem_start = lowmem_end + s->cfg.mem_hole;
+
+        memory_region_init_alias(&s->mr_lowmem, OBJECT(s), "lowmem",
+                                 s->mr_memdev, 0, s->cfg.mem_low_size);
+        memory_region_init_alias(&s->mr_highmem, OBJECT(s), "highmem",
+                                 s->mr_memdev, s->cfg.mem_low_size,
+                                 mem_size - s->cfg.mem_low_size);
+
+        memory_region_add_subregion(&s->mr, s->cfg.mem_offset, &s->mr_lowmem);
+        memory_region_add_subregion(&s->mr, highmem_start, &s->mr_highmem);
+    } else {
+        memory_region_init_alias(&s->mr_lowmem, OBJECT(s), "mem",
+                                 s->mr_memdev, 0, mem_size);
+        memory_region_add_subregion(&s->mr, s->cfg.mem_offset, &s->mr_lowmem);
+    }
+
+    address_space_init(&s->as, MEMORY_REGION(&s->mr), "msg-bus-as");
+}
+
+static Property virtio_msg_bus_ivshmem_props[] = {
+    DEFINE_PROP_STRING("dev", VirtIOMSGBusIVSHMEM, cfg.dev),
+    DEFINE_PROP_UINT32("remote-vmid", VirtIOMSGBusIVSHMEM, cfg.remote_vmid, 0),
+    DEFINE_PROP_BOOL("reset-queues", VirtIOMSGBusIVSHMEM,
+                     cfg.reset_queues, false),
+    DEFINE_PROP_LINK("memdev", VirtIOMSGBusIVSHMEM, cfg.memdev,
+                     TYPE_MEMORY_BACKEND, HostMemoryBackend *),
+    DEFINE_PROP_UINT64("mem-offset", VirtIOMSGBusIVSHMEM, cfg.mem_offset, 0),
+    DEFINE_PROP_UINT64("mem-low-size", VirtIOMSGBusIVSHMEM,
+                       cfg.mem_low_size, 0),
+    DEFINE_PROP_UINT64("mem-hole", VirtIOMSGBusIVSHMEM,
+                       cfg.mem_hole, 0),
+    DEFINE_PROP_STRING("iommu", VirtIOMSGBusIVSHMEM, cfg.iommu),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_msg_bus_ivshmem_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtIOMSGBusDeviceClass *bdc = VIRTIO_MSG_BUS_DEVICE_CLASS(klass);
+
+    bdc->process = virtio_msg_bus_ivshmem_process;
+    bdc->send = virtio_msg_bus_ivshmem_send;
+    bdc->get_remote_as = virtio_msg_bus_ivshmem_get_remote_as;
+
+    device_class_set_parent_realize(dc, virtio_msg_bus_ivshmem_realize,
+                                    &bdc->parent_realize);
+    device_class_set_props(dc, virtio_msg_bus_ivshmem_props);
+}
+
+static const TypeInfo virtio_msg_bus_ivshmem_info = {
+    .name = TYPE_VIRTIO_MSG_BUS_IVSHMEM,
+    .parent = TYPE_VIRTIO_MSG_BUS_DEVICE,
+    .instance_size = sizeof(VirtIOMSGBusIVSHMEM),
+    .class_init = virtio_msg_bus_ivshmem_class_init,
+};
+
+static void virtio_msg_bus_ivshmem_register_types(void)
+{
+    type_register_static(&virtio_msg_bus_ivshmem_info);
+}
+
+type_init(virtio_msg_bus_ivshmem_register_types)
diff --git a/hw/virtio/virtio-msg-bus-linux-user.c b/hw/virtio/virtio-msg-bus-linux-user.c
new file mode 100644
index 0000000000..4628b05a5b
--- /dev/null
+++ b/hw/virtio/virtio-msg-bus-linux-user.c
@@ -0,0 +1,228 @@
+/*
+ * VirtIO MSG bus on Linux user.
+ * This uses switchboards underlying queue's (mmap) to transfer messages
+ * and unix sockets to signal notifications.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "qapi/error.h"
+#include "hw/qdev-properties.h"
+#include "hw/qdev-properties-system.h"
+
+#include "hw/virtio/virtio-msg-bus-linux-user.h"
+
+static void virtio_msg_bus_linux_user_send_notify(VirtIOMSGBusLinuxUser *s)
+{
+    uint8_t c = 0xed;
+
+    qemu_chr_fe_write_all(&s->cfg.chr, &c, sizeof c);
+}
+
+static AddressSpace *
+virtio_msg_bus_linux_user_get_remote_as(VirtIOMSGBusDevice *bd)
+{
+    VirtIOMSGBusLinuxUser *s = VIRTIO_MSG_BUS_LINUX_USER(bd);
+
+    if (!s->cfg.memdev) {
+        return NULL;
+    }
+    return &s->as;
+}
+
+static void virtio_msg_bus_linux_user_process(VirtIOMSGBusDevice *bd) {
+    VirtIOMSGBusLinuxUser *s = VIRTIO_MSG_BUS_LINUX_USER(bd);
+    spsc_queue *q;
+    VirtIOMSG msg;
+    bool r;
+
+    /*
+     * We process the opposite queue, i.e, a driver will want to receive
+     * messages on the backend queue (and send messages on the driver queue).
+     */
+    q = bd->peer->is_driver ? s->shm_queues.device : s->shm_queues.driver;
+    do {
+        r = spsc_recv(q, &msg, sizeof msg);
+        if (r) {
+            virtio_msg_bus_receive(bd, &msg);
+        }
+    } while (r);
+}
+
+static int virtio_msg_bus_linux_user_send(VirtIOMSGBusDevice *bd,
+                                          VirtIOMSG *msg_req,
+                                          VirtIOMSG *msg_resp)
+{
+    VirtIOMSGBusLinuxUser *s = VIRTIO_MSG_BUS_LINUX_USER(bd);
+    spsc_queue *q_tx;
+    spsc_queue *q_rx;
+    bool sent;
+    int i;
+
+    q_tx = bd->peer->is_driver ? s->shm_queues.driver : s->shm_queues.device;
+    q_rx = bd->peer->is_driver ? s->shm_queues.device : s->shm_queues.driver;
+
+    do {
+        sent = spsc_send(q_tx, msg_req, sizeof *msg_req);
+    } while (!sent);
+
+    virtio_msg_bus_linux_user_send_notify(s);
+
+    if (msg_resp) {
+        bool r = false;
+
+        for (i = 0; !r && i < 1024; i++){
+            r = spsc_recv(q_rx, msg_resp, sizeof *msg_resp);
+
+            if (!r) {
+                /* No message available, keep going with some delay.  */
+                if (i > 128) {
+                    usleep(i / 128);
+                }
+            }
+
+            if (r && !virtio_msg_is_resp(msg_req, msg_resp)) {
+                /* Let the virtio-msg stack handle this.  */
+                virtio_msg_bus_ooo_receive(bd, msg_req, msg_resp);
+                /* Keep going.  */
+                r = false;
+            }
+        }
+        if (!r) {
+            /*
+             * FIXME: Devices/backends need to be able to recover from
+             * errors like this. Think a QEMU instance serving multiple
+             * guests via multiple virtio-msg devs. Can't allow one of
+             * them to bring down the entire QEMU.
+             */
+            printf("ERROR: %s: timed out!!\n", __func__);
+            abort();
+        }
+
+        /*
+         * We've got our response. Unpack it and return back to the caller.
+         */
+        virtio_msg_unpack(msg_resp);
+    }
+
+    return VIRTIO_MSG_NO_ERROR;
+}
+
+static int virtio_msg_bus_linux_user_can_receive(void *opaque)
+{
+    /* Consume multiple piled up notifications.  */
+    return 128;
+}
+
+static void virtio_msg_bus_linux_user_receive(void *opaque,
+                                              const uint8_t *buf, int size)
+{
+    VirtIOMSGBusDevice *bd = VIRTIO_MSG_BUS_DEVICE(opaque);
+
+    virtio_msg_bus_process(bd);
+}
+
+static void virtio_msg_bus_linux_user_realize(DeviceState *dev, Error **errp)
+{
+    VirtIOMSGBusLinuxUser *s = VIRTIO_MSG_BUS_LINUX_USER(dev);
+    VirtIOMSGBusDeviceClass *bdc = VIRTIO_MSG_BUS_DEVICE_GET_CLASS(dev);
+    g_autofree char *name_driver = NULL;
+    g_autofree char *name_device = NULL;
+    uint64_t mem_size;
+
+    bdc->parent_realize(dev, errp);
+    if (*errp) {
+        return;
+    }
+
+    if (s->cfg.name == NULL) {
+        error_setg(errp, "property 'name' not specified.");
+        return;
+    }
+
+    name_driver = g_strdup_printf("queue-%s-driver", s->cfg.name);
+    name_device = g_strdup_printf("queue-%s-device", s->cfg.name);
+
+    s->shm_queues.driver = spsc_open(name_driver, 4096);
+    s->shm_queues.device = spsc_open(name_device, 4096);
+
+    qemu_chr_fe_set_handlers(&s->cfg.chr,
+                             virtio_msg_bus_linux_user_can_receive,
+                             virtio_msg_bus_linux_user_receive,
+                             NULL, NULL, s, NULL, true);
+
+    if (s->cfg.memdev == NULL) {
+        /* No memory mappings needed.  */
+        return;
+    }
+
+    s->mr_memdev = host_memory_backend_get_memory(s->cfg.memdev);
+    memory_region_init(&s->mr, OBJECT(s), "mr", UINT64_MAX);
+
+    mem_size = memory_region_size(s->mr_memdev);
+    if (s->cfg.mem_hole > 0) {
+        uint64_t lowmem_end = s->cfg.mem_offset + s->cfg.mem_low_size;
+        uint64_t highmem_start = lowmem_end + s->cfg.mem_hole;
+
+        memory_region_init_alias(&s->mr_lowmem, OBJECT(s), "lowmem",
+                                 s->mr_memdev, 0, s->cfg.mem_low_size);
+        memory_region_init_alias(&s->mr_highmem, OBJECT(s), "highmem",
+                                 s->mr_memdev, s->cfg.mem_low_size,
+                                 mem_size - s->cfg.mem_low_size);
+
+        memory_region_add_subregion(&s->mr, s->cfg.mem_offset, &s->mr_lowmem);
+        memory_region_add_subregion(&s->mr, highmem_start, &s->mr_highmem);
+    } else {
+        memory_region_init_alias(&s->mr_lowmem, OBJECT(s), "mem",
+                                 s->mr_memdev, 0, mem_size);
+        memory_region_add_subregion(&s->mr, s->cfg.mem_offset, &s->mr_lowmem);
+    }
+
+    address_space_init(&s->as, MEMORY_REGION(&s->mr), "msg-bus-as");
+}
+
+static Property virtio_msg_bus_linux_user_props[] = {
+    DEFINE_PROP_STRING("name", VirtIOMSGBusLinuxUser, cfg.name),
+    DEFINE_PROP_LINK("memdev", VirtIOMSGBusLinuxUser, cfg.memdev,
+                     TYPE_MEMORY_BACKEND, HostMemoryBackend *),
+    DEFINE_PROP_UINT64("mem-offset", VirtIOMSGBusLinuxUser, cfg.mem_offset, 0),
+    DEFINE_PROP_UINT64("mem-low-size", VirtIOMSGBusLinuxUser,
+                       cfg.mem_low_size, 0),
+    DEFINE_PROP_UINT64("mem-hole", VirtIOMSGBusLinuxUser,
+                       cfg.mem_hole, 0),
+    DEFINE_PROP_CHR("chardev", VirtIOMSGBusLinuxUser, cfg.chr),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_msg_bus_linux_user_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtIOMSGBusDeviceClass *bdc = VIRTIO_MSG_BUS_DEVICE_CLASS(klass);
+
+    bdc->process = virtio_msg_bus_linux_user_process;
+    bdc->send = virtio_msg_bus_linux_user_send;
+    bdc->get_remote_as = virtio_msg_bus_linux_user_get_remote_as;
+
+    device_class_set_parent_realize(dc, virtio_msg_bus_linux_user_realize,
+                                    &bdc->parent_realize);
+    device_class_set_props(dc, virtio_msg_bus_linux_user_props);
+}
+
+static const TypeInfo virtio_msg_bus_linux_user_info = {
+    .name = TYPE_VIRTIO_MSG_BUS_LINUX_USER,
+    .parent = TYPE_VIRTIO_MSG_BUS_DEVICE,
+    .instance_size = sizeof(VirtIOMSGBusLinuxUser),
+    .class_init = virtio_msg_bus_linux_user_class_init,
+};
+
+static void virtio_msg_bus_linux_user_register_types(void)
+{
+    type_register_static(&virtio_msg_bus_linux_user_info);
+}
+
+type_init(virtio_msg_bus_linux_user_register_types)
diff --git a/hw/virtio/virtio-msg-bus-sapphire.c b/hw/virtio/virtio-msg-bus-sapphire.c
new file mode 100644
index 0000000000..951b09fbf1
--- /dev/null
+++ b/hw/virtio/virtio-msg-bus-sapphire.c
@@ -0,0 +1,297 @@
+/*
+ * VirtIO MSG bus for sapphire board with an attached vek280.
+ * This uses switchboards underlying queue's (mmap) to transfer message.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include <linux/vfio.h>
+#include "qemu/units.h"
+#include "qemu/event_notifier.h"
+#include "qemu/main-loop.h"
+#include "qapi/error.h"
+#include "hw/qdev-properties.h"
+#include "hw/qdev-properties-system.h"
+
+#include "hw/virtio/virtio-msg-bus-sapphire.h"
+#include "hw/virtio/pagemap.h"
+
+#ifdef CONFIG_XEN
+#include "hw/xen/xen_native.h"
+#include "sysemu/xen.h"
+#endif
+
+#include <sys/mman.h>
+
+#define PTIMER_POLICY                       \
+    (PTIMER_POLICY_WRAP_AFTER_ONE_PERIOD |  \
+     PTIMER_POLICY_CONTINUOUS_TRIGGER    |  \
+     PTIMER_POLICY_NO_IMMEDIATE_TRIGGER  |  \
+     PTIMER_POLICY_NO_IMMEDIATE_RELOAD   |  \
+     PTIMER_POLICY_NO_COUNTER_ROUND_DOWN)
+
+#define BAR2_DOORBELL  0x0
+
+static inline void sapphire_write32(void *p, uint32_t val) {
+        intptr_t addr = (intptr_t) p;
+
+        assert((addr % sizeof val) == 0);
+        *(volatile uint32_t *)p = val;
+}
+
+static inline uint32_t sapphire_read32(void *p) {
+        intptr_t addr = (intptr_t) p;
+        uint32_t val;
+
+        assert((addr % sizeof val) == 0);
+        val = *(volatile uint32_t *)p;
+        return val;
+}
+
+static void virtio_msg_bus_sapphire_send_notify(VirtIOMSGBusSapphire *s)
+{
+    /* Issue a pulse.  */
+    sapphire_write32(s->msg.doorbell + BAR2_DOORBELL,  1);
+    usleep(10);
+    sapphire_write32(s->msg.doorbell + BAR2_DOORBELL,  0);
+    usleep(10);
+}
+
+static void virtio_msg_bus_sapphire_process(VirtIOMSGBusDevice *bd) {
+    VirtIOMSGBusSapphire *s = VIRTIO_MSG_BUS_SAPPHIRE(bd);
+    spsc_queue *q;
+    VirtIOMSG msg;
+    bool r;
+
+    /*
+     * We process the opposite queue, i.e, a driver will want to receive
+     * messages on the backend queue (and send messages on the driver queue).
+     */
+    q = bd->peer->is_driver ? s->shm_queues.device : s->shm_queues.driver;
+    do {
+        r = spsc_recv(q, &msg, sizeof msg);
+        if (r) {
+            virtio_msg_bus_receive(bd, &msg);
+        }
+    } while (r);
+}
+
+static void sapphire_intx_interrupt(void *opaque)
+{
+    VirtIOMSGBusSapphire *s = VIRTIO_MSG_BUS_SAPPHIRE(opaque);
+    VirtIOMSGBusDevice *bd = VIRTIO_MSG_BUS_DEVICE(opaque);
+
+    if (!event_notifier_test_and_clear(&s->notifier)) {
+        return;
+    }
+
+    /* ACK the interrupt.  */
+    virtio_msg_bus_process(bd);
+    qemu_vfio_pci_unmask_irq(s->msg.dev, VFIO_PCI_INTX_IRQ_INDEX);
+}
+
+static void sapphire_timer_tick(void *opaque)
+{
+    VirtIOMSGBusSapphire *s = VIRTIO_MSG_BUS_SAPPHIRE(opaque);
+    VirtIOMSGBusDevice *bd = VIRTIO_MSG_BUS_DEVICE(opaque);
+
+    virtio_msg_bus_process(bd);
+    timer_mod_ns(&s->timer,
+                 qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + 1000 * 1000);
+}
+
+static int virtio_msg_bus_sapphire_send(VirtIOMSGBusDevice *bd, VirtIOMSG *msg_req,
+                                          VirtIOMSG *msg_resp)
+{
+    VirtIOMSGBusSapphire *s = VIRTIO_MSG_BUS_SAPPHIRE(bd);
+    spsc_queue *q_tx;
+    spsc_queue *q_rx;
+    bool sent;
+    int i;
+
+    q_tx = bd->peer->is_driver ? s->shm_queues.driver : s->shm_queues.device;
+    q_rx = bd->peer->is_driver ? s->shm_queues.device : s->shm_queues.driver;
+
+    virtio_msg_bus_sapphire_send_notify(s);
+    do {
+        sent = spsc_send(q_tx, msg_req, sizeof *msg_req);
+    } while (!sent);
+
+    virtio_msg_bus_sapphire_send_notify(s);
+
+    if (msg_resp) {
+        bool r = false;
+
+        for (i = 0; !r && i < 1024 * 10000; i++){
+            r = spsc_recv(q_rx, msg_resp, sizeof *msg_resp);
+
+            if (!r) {
+                /* No message available, keep going with some delay.  */
+                if (i > 128) {
+                    if (!s->shm_queues.flowing) {
+                        virtio_msg_bus_sapphire_send_notify(s);
+                    }
+                    usleep(i / 128);
+                }
+            }
+
+            if (r && !virtio_msg_is_resp(msg_req, msg_resp)) {
+                /* Let the virtio-msg stack handle this.  */
+                virtio_msg_bus_ooo_receive(bd, msg_req, msg_resp);
+                /* Keep going.  */
+                r = 0;
+            }
+        }
+        if (!r) {
+            /*
+             * FIXME: Devices/backends need to be able to recover from
+             * errors like this. Think a QEMU instance serving multiple
+             * guests via multiple virtio-msg devs. Can't allow one of
+             * them to bring down the entire QEMU.
+             */
+            printf("ERROR: %s: timed out!!\n", __func__);
+            abort();
+        }
+
+        s->shm_queues.flowing = true;
+
+        /*
+         * We've got our response. Unpack it and return back to the caller.
+         */
+        virtio_msg_unpack(msg_resp);
+    }
+
+    return VIRTIO_MSG_NO_ERROR;
+}
+
+static void virtio_msg_bus_sapphire_realize(DeviceState *dev, Error **errp)
+{
+    VirtIOMSGBusSapphire *s = VIRTIO_MSG_BUS_SAPPHIRE(dev);
+    VirtIOMSGBusDevice *bd = VIRTIO_MSG_BUS_DEVICE(dev);
+    VirtIOMSGBusDeviceClass *bdc = VIRTIO_MSG_BUS_DEVICE_GET_CLASS(dev);
+    uint64_t iova;
+    int ret;
+
+    bdc->parent_realize(dev, errp);
+    if (*errp) {
+        return;
+    }
+
+    if (s->cfg.dev == NULL) {
+        error_setg(errp, "property 'dev' not specified.");
+        return;
+    }
+
+    ret = event_notifier_init(&s->notifier, 0);
+    if (ret) {
+        error_setg(errp, "Failed to init event notifier");
+        return;
+    }
+
+    if (s->cfg.iommu) {
+        if (!strcmp(s->cfg.iommu, "xen-gfn2mfn")) {
+            bd->iommu_translate = virtio_msg_bus_xen_gfn2mfn_translate;
+        } else if (!strcmp(s->cfg.iommu, "xen-virt2gfn")) {
+            bd->iommu_translate = virtio_msg_bus_xen_virt2gfn_translate;
+        } else if (!strcmp(s->cfg.iommu, "linux-proc-pagemap")) {
+            bd->iommu_translate = virtio_msg_bus_pagemap_translate;
+        }
+    }
+
+    s->msg.dev = qemu_vfio_open_pci(s->cfg.dev, &error_fatal);
+
+    s->msg.doorbell = qemu_vfio_pci_map_bar(s->msg.dev, 2, 0, 4 * KiB,
+                                            PROT_READ | PROT_WRITE,
+                                            &error_fatal);
+
+    s->msg.cfg_bram = qemu_vfio_pci_map_bar(s->msg.dev, 1, 0x4000, 4 * KiB,
+                                            PROT_READ | PROT_WRITE,
+                                            &error_fatal);
+
+    if (0) {
+        qemu_vfio_pci_init_irq(s->msg.dev, &s->notifier,
+                VFIO_PCI_INTX_IRQ_INDEX, &error_fatal);
+        qemu_set_fd_handler(event_notifier_get_fd(&s->notifier),
+                sapphire_intx_interrupt, NULL, s);
+    }
+
+#if 0
+    memory_region_init_ram(&s->shm_queues.mr, NULL, "spsc-ram",
+                           4 * 2 * 1024, &error_fatal);
+
+    s->msg.driver = memory_region_get_ram_ptr(&s->shm_queues.mr);
+    s->msg.device = s->msg.driver + 4 * 1024;
+#else
+    s->msg.driver = mmap(NULL, 8 * 1024, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE | MAP_ANONYMOUS, -1, 0);
+    s->msg.device = s->msg.driver + 4 * 1024;
+#endif
+
+    if (s->cfg.reset_queues) {
+        memset(s->msg.driver, 0, 4 * KiB);
+        memset(s->msg.device, 0, 4 * KiB);
+    }
+
+    s->shm_queues.driver = spsc_open_mem("queue-driver",
+                                         spsc_capacity(4 * KiB), s->msg.driver);
+    s->shm_queues.device = spsc_open_mem("queue-device",
+                                         spsc_capacity(4 * KiB), s->msg.device);
+
+    printf("map spsc queues\n");
+    if (1) {
+        iova = pagemap_virt_to_phys(s->msg.driver);
+    } else {
+        qemu_vfio_dma_map(s->msg.dev, s->msg.driver, 8 * 1024, false,
+                &iova, &error_warn);
+    }
+    printf("spsc va=%p iova=%lx\n", s->msg.driver, iova);
+    s->msg.cfg_bram[1] = iova;
+    s->msg.cfg_bram[2] = iova >> 32;
+    smp_wmb();
+    s->msg.cfg_bram[0] = 1;
+    smp_wmb();
+
+    timer_init_ns(&s->timer, QEMU_CLOCK_REALTIME, sapphire_timer_tick, s);
+    timer_mod_ns(&s->timer,
+                 qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + 1000 * 1000);
+
+    mlockall(MCL_CURRENT | MCL_FUTURE);
+}
+
+static Property virtio_msg_bus_sapphire_props[] = {
+    DEFINE_PROP_STRING("dev", VirtIOMSGBusSapphire, cfg.dev),
+    DEFINE_PROP_BOOL("reset-queues", VirtIOMSGBusSapphire,
+                     cfg.reset_queues, false),
+    DEFINE_PROP_STRING("iommu", VirtIOMSGBusSapphire, cfg.iommu),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_msg_bus_sapphire_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtIOMSGBusDeviceClass *bdc = VIRTIO_MSG_BUS_DEVICE_CLASS(klass);
+
+    bdc->process = virtio_msg_bus_sapphire_process;
+    bdc->send = virtio_msg_bus_sapphire_send;
+
+    device_class_set_parent_realize(dc, virtio_msg_bus_sapphire_realize,
+                                    &bdc->parent_realize);
+    device_class_set_props(dc, virtio_msg_bus_sapphire_props);
+}
+
+static const TypeInfo virtio_msg_bus_sapphire_info = {
+    .name = TYPE_VIRTIO_MSG_BUS_SAPPHIRE,
+    .parent = TYPE_VIRTIO_MSG_BUS_DEVICE,
+    .instance_size = sizeof(VirtIOMSGBusSapphire),
+    .class_init = virtio_msg_bus_sapphire_class_init,
+};
+
+static void virtio_msg_bus_sapphire_register_types(void)
+{
+    type_register_static(&virtio_msg_bus_sapphire_info);
+}
+
+type_init(virtio_msg_bus_sapphire_register_types)
diff --git a/hw/virtio/virtio-msg-bus-vek280-hexcam.c b/hw/virtio/virtio-msg-bus-vek280-hexcam.c
new file mode 100644
index 0000000000..f3e203d291
--- /dev/null
+++ b/hw/virtio/virtio-msg-bus-vek280-hexcam.c
@@ -0,0 +1,371 @@
+/*
+ * VirtIO MSG bus for the VEK280 hexcam design.
+ * This uses switchboards underlying queue's (mmap) to transfer messages.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include <linux/vfio.h>
+#include "qemu/units.h"
+#include "qemu/event_notifier.h"
+#include "qemu/main-loop.h"
+#include "qapi/error.h"
+#include "hw/qdev-properties.h"
+#include "hw/qdev-properties-system.h"
+
+#include "hw/virtio/virtio-msg-bus-vek280-hexcam.h"
+
+#define VEK280_INTR_STATUS    0x0
+
+static inline void vek280_write32(void *p, uint32_t val) {
+        intptr_t addr = (intptr_t) p;
+
+        assert((addr % sizeof val) == 0);
+        *(volatile uint32_t *)p = val;
+}
+
+static inline void vek280_write64(void *p, uint64_t val) {
+        intptr_t addr = (intptr_t) p;
+
+        assert((addr % sizeof val) == 0);
+        *(volatile uint64_t *)p = val;
+}
+
+static inline uint32_t vek280_read32(void *p) {
+        intptr_t addr = (intptr_t) p;
+        uint32_t val;
+
+        assert((addr % sizeof val) == 0);
+        val = *(volatile uint32_t *)p;
+        return val;
+}
+
+static inline uint64_t vek280_read64(void *p) {
+        intptr_t addr = (intptr_t) p;
+        uint64_t val;
+
+        assert((addr % sizeof val) == 0);
+        val = *(volatile uint64_t *)p;
+        return val;
+}
+
+static void virtio_msg_bus_vek280_send_notify(VirtIOMSGBusVEK280HexCam *s)
+{
+    vek280_write32(s->msg.doorbell, 0x1);
+    usleep(10);
+    vek280_write32(s->msg.doorbell, 0x0);
+    usleep(10);
+}
+
+static AddressSpace *virtio_msg_bus_vek280_get_remote_as(VirtIOMSGBusDevice *bd)
+{
+    VirtIOMSGBusVEK280HexCam *s = VIRTIO_MSG_BUS_VEK280_HEXCAM(bd);
+
+    return &s->as;
+}
+
+static void virtio_msg_bus_vek280_process(VirtIOMSGBusDevice *bd) {
+    VirtIOMSGBusVEK280HexCam *s = VIRTIO_MSG_BUS_VEK280_HEXCAM(bd);
+    spsc_queue *q;
+    VirtIOMSG msg;
+    bool r;
+
+    /*
+     * We process the opposite queue, i.e, a driver will want to receive
+     * messages on the backend queue (and send messages on the driver queue).
+     */
+    q = bd->peer->is_driver ? s->shm_queues.device : s->shm_queues.driver;
+    do {
+        r = spsc_recv(q, &msg, sizeof msg);
+        if (r) {
+            virtio_msg_bus_receive(bd, &msg);
+        }
+    } while (r);
+}
+
+static void vek280_mask_interrupt(VirtIOMSGBusVEK280HexCam *s, bool mask)
+{
+    uint32_t info = 1;
+    ssize_t nb;
+
+    if (mask) {
+        nb = read(s->msg.fd, &info, sizeof(info));
+    } else {
+        nb = write(s->msg.fd, &info, sizeof(info));
+    }
+    if (nb != (ssize_t) sizeof(info)) {
+        perror("vek280_unmask_interrupt: write");
+    }
+}
+
+static void vek280_interrupt(void *opaque)
+{
+    VirtIOMSGBusVEK280HexCam *s = VIRTIO_MSG_BUS_VEK280_HEXCAM(opaque);
+    VirtIOMSGBusDevice *bd = VIRTIO_MSG_BUS_DEVICE(opaque);
+    vek280_mask_interrupt(s, true);
+
+    /* ACK the interrupt.  */
+    virtio_msg_bus_process(bd);
+    vek280_mask_interrupt(s, false);
+    /* avoid race. */
+    virtio_msg_bus_process(bd);
+}
+
+static int virtio_msg_bus_vek280_send(VirtIOMSGBusDevice *bd, VirtIOMSG *msg_req,
+                                          VirtIOMSG *msg_resp)
+{
+    VirtIOMSGBusVEK280HexCam *s = VIRTIO_MSG_BUS_VEK280_HEXCAM(bd);
+    spsc_queue *q_tx;
+    spsc_queue *q_rx;
+    bool sent;
+    int i;
+
+    q_tx = bd->peer->is_driver ? s->shm_queues.driver : s->shm_queues.device;
+    q_rx = bd->peer->is_driver ? s->shm_queues.device : s->shm_queues.driver;
+
+    do {
+        sent = spsc_send(q_tx, msg_req, sizeof *msg_req);
+    } while (!sent);
+
+    virtio_msg_bus_vek280_send_notify(s);
+
+    if (msg_resp) {
+        bool r = false;
+
+        for (i = 0; !r && i < 1024; i++){
+            r = spsc_recv(q_rx, msg_resp, sizeof *msg_resp);
+
+            if (!r) {
+                /* No message available, keep going with some delay.  */
+                if (i > 128) {
+                    usleep(i / 128);
+                }
+            }
+
+            if (r && !virtio_msg_is_resp(msg_req, msg_resp)) {
+                /* Let the virtio-msg stack handle this.  */
+                virtio_msg_bus_ooo_receive(bd, msg_req, msg_resp);
+                /* Keep going.  */
+                r = 0;
+            }
+        }
+        if (!r) {
+            /*
+             * FIXME: Devices/backends need to be able to recover from
+             * errors like this. Think a QEMU instance serving multiple
+             * guests via multiple virtio-msg devs. Can't allow one of
+             * them to bring down the entire QEMU.
+             */
+            printf("ERROR: %s: timed out!!\n", __func__);
+            abort();
+        }
+
+        /*
+         * We've got our response. Unpack it and return back to the caller.
+         */
+        virtio_msg_unpack(msg_resp);
+    }
+
+    return VIRTIO_MSG_NO_ERROR;
+}
+
+static void virtio_msg_bus_vek280_realize(DeviceState *dev, Error **errp)
+{
+    VirtIOMSGBusVEK280HexCam *s = VIRTIO_MSG_BUS_VEK280_HEXCAM(dev);
+    VirtIOMSGBusDevice *bd = VIRTIO_MSG_BUS_DEVICE(dev);
+    VirtIOMSGBusDeviceClass *bdc = VIRTIO_MSG_BUS_DEVICE_GET_CLASS(dev);
+    int ret;
+
+    bdc->parent_realize(dev, errp);
+    if (*errp) {
+        return;
+    }
+
+    if (s->cfg.dev == NULL) {
+        error_setg(errp, "property 'dev' not specified.");
+        return;
+    }
+
+    ret = event_notifier_init(&s->notifier, 0);
+    if (ret) {
+        error_setg(errp, "Failed to init event notifier");
+        return;
+    }
+
+    if (s->cfg.iommu) {
+        if (!strcmp(s->cfg.iommu, "xen-gfn2mfn")) {
+            bd->iommu_translate = virtio_msg_bus_xen_gfn2mfn_translate;
+        } else if (!strcmp(s->cfg.iommu, "linux-proc-pagemap")) {
+            bd->iommu_translate = virtio_msg_bus_pagemap_translate;
+        }
+    }
+
+    s->msg.fd = open(s->cfg.dev, O_RDWR);
+    s->msg.fd_devmem = open("/dev/mem", O_RDWR);
+
+    qemu_set_fd_handler(s->msg.fd,
+                        vek280_interrupt, NULL, s);
+
+    if (s->cfg.reset_queues) {
+        memset(s->msg.driver, 0, 4 * KiB);
+        memset(s->msg.device, 0, 4 * KiB);
+    }
+
+#if 0
+    memory_region_init_ram_from_file(&s->mr_host, OBJECT(s), "mr-host",
+                                     0x8f000000, 0x100000,
+                                     RAM_SHARED | RAM_NAMED_FILE,
+                                     "/dev/mem",
+                                     0x4A000000000ULL,
+                                     &error_abort);
+#else
+#if 0
+    // KVM
+    memory_region_init_ram_from_fd(&s->mr_host, OBJECT(s), "mr-host",
+                                     0x810c2000ULL,
+                                     RAM_SHARED,
+                                     s->msg.fd,
+                                     0,
+                                     &error_abort);
+
+    memory_region_init_alias(&s->mr_host_ram, OBJECT(s), "mr-host-ram",
+                             &s->mr_host,
+                             0x10000 /* QEMU_VFIO_IOVA_MIN */, 0x80000000);
+
+    memory_region_init_alias(&s->mr_host_ram_alias, OBJECT(s),
+                             "mr-host-ram-alias",
+                             &s->mr_host,
+                             0x10000 /* QEMU_VFIO_IOVA_MIN */, 0x80000000);
+
+#else
+    memory_region_init_ram_from_fd(&s->mr_host, OBJECT(s), "mr-host",
+                                     s->cfg.mem_size,
+                                     RAM_SHARED | RAM_NORESERVE,
+                                     s->msg.fd,
+                                     0,
+                                     &error_abort);
+
+    memory_region_init_alias(&s->mr_host_ram, OBJECT(s), "mr-host-ram",
+                             &s->mr_host,
+                             s->cfg.mem_offset, s->cfg.mem_size);
+
+    memory_region_init_alias(&s->mr_host_ram_alias, OBJECT(s),
+                             "mr-host-ram-alias",
+                             &s->mr_host,
+                             s->cfg.mem_offset, s->cfg.mem_size);
+#endif
+#endif
+
+    address_space_init(&s->as, MEMORY_REGION(&s->mr_host_ram), "msg-bus-as");
+    memory_region_add_subregion(get_system_memory(), 0, &s->mr_host_ram_alias);
+
+    s->msg.host = memory_region_get_ram_ptr(&s->mr_host);
+    printf("host=%p\n", s->msg.host);
+    // Linux/KVM
+    //s->msg.driver = s->msg.host + 0x810c0000ULL;
+
+    s->msg.doorbell = mmap(0, 4 * 1024, PROT_READ | PROT_WRITE, MAP_SHARED,
+                           s->msg.fd_devmem, 0x20180000000ULL);
+    assert(s->msg.doorbell != MAP_FAILED);
+
+    s->msg.cfg_bram = mmap(0, 8 * 1024, PROT_READ | PROT_WRITE, MAP_SHARED,
+                           s->msg.fd_devmem, 0x020200004000ULL);
+    assert(s->msg.cfg_bram != MAP_FAILED);
+
+    /* Wait for queue setup. */
+    printf("Wait for queue\n");
+    do {
+        usleep(100);
+    } while (s->msg.cfg_bram[0] == 0);
+    printf("cfg-bram: %x %x %x\n",
+            s->msg.cfg_bram[0],
+            s->msg.cfg_bram[1],
+            s->msg.cfg_bram[2]);
+    smp_rmb();
+    s->cfg.spsc_base = s->msg.cfg_bram[2];
+    s->cfg.spsc_base <<= 32;
+    s->cfg.spsc_base |= s->msg.cfg_bram[1];
+    smp_mb();
+    s->msg.cfg_bram[0] = 0;
+
+    printf("Found queue at %lx\n", s->cfg.spsc_base);
+
+    // Xen, changes every time.
+    s->msg.driver = s->msg.host + s->cfg.spsc_base;
+    s->msg.device = s->msg.driver + 4 * 1024;
+
+    virtio_msg_bus_vek280_send_notify(s);
+
+    if (0) {
+        uint64_t i;
+
+        printf("compare all RAM\n");
+        for (i = s->cfg.spsc_base; i < (s->cfg.spsc_base + 0x1000); i += 8) {
+            uint64_t v1, v2;
+
+            if ((i % (8 * 1024 * 1024) == 0)) {
+                printf("%lx\n", i);
+            }
+            v1 = vek280_read32(s->msg.host + i);
+            address_space_read(&s->as, i, MEMTXATTRS_UNSPECIFIED, &v2, 4);
+            assert(v1 == v2);
+            vek280_write32(s->msg.host + i, v1);
+        }
+    }
+
+    s->shm_queues.driver = spsc_open_mem("queue-driver",
+                                         spsc_capacity(4 * KiB), s->msg.driver);
+    s->shm_queues.device = spsc_open_mem("queue-device",
+                                         spsc_capacity(4 * KiB), s->msg.device);
+    vek280_mask_interrupt(s, false);
+
+    /* Lower doorbell reg.  */
+    vek280_write32(s->msg.doorbell, 0x0);
+    usleep(10);
+}
+
+static Property virtio_msg_bus_vek280_props[] = {
+    DEFINE_PROP_STRING("dev", VirtIOMSGBusVEK280HexCam, cfg.dev),
+    DEFINE_PROP_UINT64("spsc-base", VirtIOMSGBusVEK280HexCam, cfg.spsc_base,
+                       UINT64_MAX),
+    DEFINE_PROP_UINT64("mem-offset", VirtIOMSGBusVEK280HexCam, cfg.mem_offset,
+                       0),
+    DEFINE_PROP_UINT64("mem-size", VirtIOMSGBusVEK280HexCam, cfg.mem_size,
+                       0x860000000ULL),
+    DEFINE_PROP_BOOL("reset-queues", VirtIOMSGBusVEK280HexCam,
+                     cfg.reset_queues, false),
+    DEFINE_PROP_STRING("iommu", VirtIOMSGBusVEK280HexCam, cfg.iommu),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_msg_bus_vek280_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtIOMSGBusDeviceClass *bdc = VIRTIO_MSG_BUS_DEVICE_CLASS(klass);
+
+    bdc->process = virtio_msg_bus_vek280_process;
+    bdc->send = virtio_msg_bus_vek280_send;
+    bdc->get_remote_as = virtio_msg_bus_vek280_get_remote_as;
+
+    device_class_set_parent_realize(dc, virtio_msg_bus_vek280_realize,
+                                    &bdc->parent_realize);
+    device_class_set_props(dc, virtio_msg_bus_vek280_props);
+}
+
+static const TypeInfo virtio_msg_bus_vek280_info = {
+    .name = TYPE_VIRTIO_MSG_BUS_VEK280_HEXCAM,
+    .parent = TYPE_VIRTIO_MSG_BUS_DEVICE,
+    .instance_size = sizeof(VirtIOMSGBusVEK280HexCam),
+    .class_init = virtio_msg_bus_vek280_class_init,
+};
+
+static void virtio_msg_bus_vek280_register_types(void)
+{
+    type_register_static(&virtio_msg_bus_vek280_info);
+}
+
+type_init(virtio_msg_bus_vek280_register_types)
diff --git a/hw/virtio/virtio-msg-bus-xen.c b/hw/virtio/virtio-msg-bus-xen.c
new file mode 100644
index 0000000000..6532e5d36b
--- /dev/null
+++ b/hw/virtio/virtio-msg-bus-xen.c
@@ -0,0 +1,253 @@
+/*
+ * virtio-msg bus on top Xen.
+ *
+ * Uses either grant or foreign mappings for the shared queues.
+ * Uses event channels for notifications both ways.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "qapi/error.h"
+#include "hw/qdev-properties.h"
+#include "hw/qdev-properties-system.h"
+#include "hw/xen/xen_native.h"
+#include "hw/xen/xen-bus-helper.h"
+
+#include "hw/virtio/virtio-msg-bus-xen.h"
+
+#include <xengnttab.h>
+
+static xengnttab_handle *xen_region_gnttabdev;
+
+static void virtio_msg_bus_xen_send_notify(VirtIOMSGBusXen *s)
+{
+    qemu_xen_evtchn_notify(s->xen.eh, s->xen.local_port);
+}
+
+static AddressSpace *
+virtio_msg_bus_xen_get_remote_as(VirtIOMSGBusDevice *bd)
+{
+    return &address_space_memory;
+}
+
+static void virtio_msg_bus_xen_process(VirtIOMSGBusDevice *bd) {
+    VirtIOMSGBusXen *s = VIRTIO_MSG_BUS_XEN(bd);
+    spsc_queue *q;
+    VirtIOMSG msg;
+    bool r;
+
+    /*
+     * We process the opposite queue, i.e, a driver will want to receive
+     * messages on the backend queue (and send messages on the driver queue).
+     */
+    q = bd->peer->is_driver ? s->shm_queues.device : s->shm_queues.driver;
+    do {
+        r = spsc_recv(q, &msg, sizeof msg);
+        if (r) {
+            virtio_msg_bus_receive(bd, &msg);
+        }
+    } while (r);
+}
+
+static int virtio_msg_bus_xen_send(VirtIOMSGBusDevice *bd,
+                                          VirtIOMSG *msg_req,
+                                          VirtIOMSG *msg_resp)
+{
+    VirtIOMSGBusXen *s = VIRTIO_MSG_BUS_XEN(bd);
+    spsc_queue *q_tx;
+    spsc_queue *q_rx;
+    bool sent;
+    int i;
+
+    q_tx = bd->peer->is_driver ? s->shm_queues.driver : s->shm_queues.device;
+    q_rx = bd->peer->is_driver ? s->shm_queues.device : s->shm_queues.driver;
+
+    do {
+        sent = spsc_send(q_tx, msg_req, sizeof *msg_req);
+    } while (!sent);
+
+    virtio_msg_bus_xen_send_notify(s);
+
+    if (msg_resp) {
+        bool r = false;
+
+        for (i = 0; !r && i < 1024; i++){
+            r = spsc_recv(q_rx, msg_resp, sizeof *msg_resp);
+
+            if (!r) {
+                /* No message available, keep going with some delay.  */
+                if (i > 128) {
+                    usleep(i / 128);
+                }
+            }
+
+            if (r && !virtio_msg_is_resp(msg_req, msg_resp)) {
+                /* Let the virtio-msg stack handle this.  */
+                virtio_msg_bus_ooo_receive(bd, msg_req, msg_resp);
+                /* Keep going.  */
+                r = false;
+            }
+        }
+        if (!r) {
+            /*
+             * FIXME: Devices/backends need to be able to recover from
+             * errors like this. Think a QEMU instance serving multiple
+             * guests via multiple virtio-msg devs. Can't allow one of
+             * them to bring down the entire QEMU.
+             */
+            printf("ERROR: %s: timed out!!\n", __func__);
+            abort();
+        }
+
+        /*
+         * We've got our response. Unpack it and return back to the caller.
+         */
+        virtio_msg_unpack(msg_resp);
+    }
+
+    return VIRTIO_MSG_NO_ERROR;
+}
+
+static void virtio_msg_bus_xen_event(void *opaque)
+{
+    VirtIOMSGBusXen *s = VIRTIO_MSG_BUS_XEN(opaque);
+    VirtIOMSGBusDevice *bd = VIRTIO_MSG_BUS_DEVICE(opaque);
+    int port;
+
+    port = qemu_xen_evtchn_pending(s->xen.eh);
+    if (port != s->xen.local_port) {
+        return;
+    }
+
+    virtio_msg_bus_xen_process(bd);
+    qemu_xen_evtchn_unmask(s->xen.eh, port);
+}
+
+static void virtio_msg_bus_xen_map_shm(VirtIOMSGBusXen *s, Error **errp)
+{
+    uint32_t grant_ref;
+    xen_pfn_t pfn;
+    int nb_pfn = 1;
+
+    grant_ref = s->cfg.shm_base;
+
+    /* Try grants first.  */
+    if (xen_region_gnttabdev) {
+        s->xen.shm = xengnttab_map_domain_grant_refs(xen_region_gnttabdev,
+                                                     nb_pfn,
+                                                     xen_domid, &grant_ref,
+                                                     PROT_READ | PROT_WRITE);
+        if (s->xen.shm) {
+            return;
+        }
+    }
+
+    /* Grants failed, fall back to foreign mappings.  */
+    pfn = s->cfg.shm_base >> XC_PAGE_SHIFT;
+    s->xen.shm = xenforeignmemory_map2(xen_fmem, xen_domid, NULL,
+                                       PROT_READ | PROT_WRITE,
+                                       /* No flags  */ 0,
+                                       nb_pfn, &pfn, NULL);
+
+    if (!s->xen.shm) {
+        error_setg(errp, "Failed to map shm-base %lx", s->cfg.shm_base);
+    }
+}
+
+static void virtio_msg_bus_xen_realize(DeviceState *dev, Error **errp)
+{
+    VirtIOMSGBusXen *s = VIRTIO_MSG_BUS_XEN(dev);
+    VirtIOMSGBusDeviceClass *bdc = VIRTIO_MSG_BUS_DEVICE_GET_CLASS(dev);
+    int evtchn_fd;
+
+    g_autofree char *name_driver = NULL;
+    g_autofree char *name_device = NULL;
+
+    bdc->parent_realize(dev, errp);
+    if (*errp) {
+        return;
+    }
+
+    if (s->cfg.shm_base == UINT64_MAX) {
+        error_setg(errp, "shm-base not set!");
+        return;
+    }
+
+    if (!xen_region_gnttabdev) {
+        xen_region_gnttabdev = xengnttab_open(NULL, 0);
+        if (!xen_region_gnttabdev) {
+            error_setg(errp, "Failed to open gnttab device");
+            return;
+        }
+    }
+
+    virtio_msg_bus_xen_map_shm(s, errp);
+    if (*errp) {
+        return;
+    }
+
+    s->shm_queues.driver = spsc_open_mem("queue-driver",
+                                         spsc_capacity(1 * KiB),
+                                         s->xen.shm);
+    s->shm_queues.device = spsc_open_mem("queue-device",
+                                         spsc_capacity(1 * KiB),
+                                         s->xen.shm + 1 * KiB);
+    assert(s->shm_queues.driver);
+    assert(s->shm_queues.device);
+
+    s->xen.eh = qemu_xen_evtchn_open();
+    s->xen.local_port = qemu_xen_evtchn_bind_interdomain(s->xen.eh,
+                                                         xen_domid,
+                                                         s->cfg.port);
+    if (!s->xen.eh) {
+        error_setg_errno(errp, errno, "failed xenevtchn_open");
+        return;
+    }
+
+    /* Register with main loop.  */
+    evtchn_fd = qemu_xen_evtchn_fd(s->xen.eh);
+    if (evtchn_fd != -1) {
+        qemu_set_fd_handler(evtchn_fd, virtio_msg_bus_xen_event, NULL, s);
+    }
+
+    printf("%s: DONE\n", __func__);
+}
+
+static Property virtio_msg_bus_xen_props[] = {
+    DEFINE_PROP_UINT64("shm-base", VirtIOMSGBusXen, cfg.shm_base, UINT64_MAX),
+    DEFINE_PROP_UINT16("port", VirtIOMSGBusXen, cfg.port, 0),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_msg_bus_xen_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtIOMSGBusDeviceClass *bdc = VIRTIO_MSG_BUS_DEVICE_CLASS(klass);
+
+    bdc->process = virtio_msg_bus_xen_process;
+    bdc->send = virtio_msg_bus_xen_send;
+    bdc->get_remote_as = virtio_msg_bus_xen_get_remote_as;
+
+    device_class_set_parent_realize(dc, virtio_msg_bus_xen_realize,
+                                    &bdc->parent_realize);
+    device_class_set_props(dc, virtio_msg_bus_xen_props);
+}
+
+static const TypeInfo virtio_msg_bus_xen_info = {
+    .name = TYPE_VIRTIO_MSG_BUS_XEN,
+    .parent = TYPE_VIRTIO_MSG_BUS_DEVICE,
+    .instance_size = sizeof(VirtIOMSGBusXen),
+    .class_init = virtio_msg_bus_xen_class_init,
+};
+
+static void virtio_msg_bus_xen_register_types(void)
+{
+    type_register_static(&virtio_msg_bus_xen_info);
+}
+
+type_init(virtio_msg_bus_xen_register_types)
diff --git a/hw/virtio/virtio-msg-bus.c b/hw/virtio/virtio-msg-bus.c
new file mode 100644
index 0000000000..346ece7940
--- /dev/null
+++ b/hw/virtio/virtio-msg-bus.c
@@ -0,0 +1,312 @@
+/*
+ * VirtIO MSG bus.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "hw/virtio/pagemap.h"
+#include "hw/virtio/virtio-msg-bus.h"
+
+#ifdef CONFIG_XEN
+#include "hw/xen/xen_native.h"
+#endif
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <sys/ioctl.h>
+
+#define IOCTL_VIRT2GFN \
+_IOC(_IOC_READ|_IOC_WRITE, 'G', 5, sizeof(struct ioctl_xen_virt2gfn))
+struct ioctl_xen_virt2gfn {
+    /* Number of pages to map */
+    __u32 count;
+    /* padding.  */
+    __u32 padding;
+
+    /* Variable array with virt address to convert to gfns.  */
+    union {
+        __u64 addr[1];
+        __DECLARE_FLEX_ARRAY(__u64, addr_flex);
+    };
+};
+
+IOMMUTLBEntry virtio_msg_bus_xen_gfn2mfn_translate(VirtIOMSGBusDevice *bd,
+                                                   uint64_t va,
+                                                   uint8_t prot)
+{
+    IOMMUTLBEntry ret = {0};
+#ifdef CONFIG_XEN
+    hwaddr plen = VIRTIO_MSG_IOMMU_PAGE_SIZE;
+    xenmem_access_t access;
+    uint64_t mfn;
+    void *p;
+    int r;
+
+    assert((va & VIRTIO_MSG_IOMMU_PAGE_MASK) == 0);
+
+    p = address_space_map(&address_space_memory, va, &plen,
+                          prot & VIRTIO_MSG_IOMMU_PROT_WRITE,
+                          MEMTXATTRS_UNSPECIFIED);
+
+    if (!p) {
+        return ret;
+    }
+
+    ret.iova = va;
+    r = xc_domain_gfn2mfn(xen_xc, xen_domid,
+                          va >> XC_PAGE_SHIFT, &mfn, &access);
+    assert(r == 0);
+    ret.translated_addr = mfn << XC_PAGE_SHIFT;
+    ret.perm = IOMMU_ACCESS_FLAG(1, 1);
+
+    address_space_unmap(&address_space_memory, p, plen,
+                        prot & VIRTIO_MSG_IOMMU_PROT_WRITE,
+                        0);
+//    printf("%s: %lx.%lx  ->  %lx\n", __func__, va, ret.iova, ret.translated_addr);
+#endif
+    return ret;
+}
+
+IOMMUTLBEntry virtio_msg_bus_xen_virt2gfn_translate(VirtIOMSGBusDevice *bd,
+                                                    uint64_t va,
+                                                    uint8_t prot)
+{
+    struct ioctl_xen_virt2gfn op = {0};
+    IOMMUTLBEntry ret = {0};
+    hwaddr plen = VIRTIO_MSG_IOMMU_PAGE_SIZE;
+    void *p;
+    int rc;
+
+    if (bd->virt2gfn_fd == -1) {
+        bd->virt2gfn_fd = open("/dev/xen/xv2g", O_RDWR);
+        if (bd->virt2gfn_fd == -1) {
+            printf("failed to open /dev/xen/x2vg!\n");
+            return ret;
+        }
+    }
+
+    assert((va & VIRTIO_MSG_IOMMU_PAGE_MASK) == 0);
+
+    /* The assumption here is that the memory we're trying to access has
+     * already previously been mapped via address_space_map().
+     * So we're taking a second ref just to get hold of p.
+     * But the underlying mapping is expected to live beyond this translation.
+     */
+    p = address_space_map(&address_space_memory, va, &plen,
+                          prot & VIRTIO_MSG_IOMMU_PROT_WRITE,
+                          MEMTXATTRS_UNSPECIFIED);
+
+    if (!p) {
+        return ret;
+    }
+
+    ret.iova = va;
+    op.count = 1;
+    op.addr[0] = (uintptr_t) p;
+    rc = ioctl(bd->virt2gfn_fd, IOCTL_VIRT2GFN, (uintptr_t) &op);
+    assert(rc == 0);
+    ret.translated_addr = op.addr[0];
+    ret.perm = IOMMU_ACCESS_FLAG(prot & VIRTIO_MSG_IOMMU_PROT_READ,
+                                 prot & VIRTIO_MSG_IOMMU_PROT_WRITE);
+
+#if 0
+    IOMMUTLBEntry ret2 = {0};
+
+    if (bd->pagemap_fd == -1) {
+        bd->pagemap_fd = pagemap_open_self();
+        if (bd->pagemap_fd == -1) {
+            printf("failed to open /proc/self/pagemap!\n");
+            return ret;
+        }
+    }
+
+    ret2.iova = va;
+    ret2.translated_addr = pagemap_virt_to_phys_fd(bd->pagemap_fd, p);
+    ret2.perm = IOMMU_ACCESS_FLAG(prot & VIRTIO_MSG_IOMMU_PROT_READ,
+                                 prot & VIRTIO_MSG_IOMMU_PROT_WRITE);
+
+    if (ret.translated_addr != ret2.translated_addr) {
+        printf("%s: iommu missmatch va %lx %lx != %lx\n", __func__,
+                va, ret.translated_addr, ret2.translated_addr);
+    }
+#endif
+
+//    printf("%s: %p %lx.%lx  ->  %lx\n", __func__,
+//           p, va, ret.iova, ret.translated_addr);
+    return ret;
+}
+
+IOMMUTLBEntry virtio_msg_bus_pagemap_translate(VirtIOMSGBusDevice *bd,
+                                               uint64_t va,
+                                               uint8_t prot)
+{
+    IOMMUTLBEntry ret = {0};
+    hwaddr plen = VIRTIO_MSG_IOMMU_PAGE_SIZE;
+    void *p;
+
+    if (bd->pagemap_fd == -1) {
+        bd->pagemap_fd = pagemap_open_self();
+        if (bd->pagemap_fd == -1) {
+            printf("failed to open /proc/self/pagemap!\n");
+            return ret;
+        }
+    }
+
+    assert((va & VIRTIO_MSG_IOMMU_PAGE_MASK) == 0);
+
+    p = address_space_map(&address_space_memory, va, &plen,
+                          prot & VIRTIO_MSG_IOMMU_PROT_WRITE,
+                          MEMTXATTRS_UNSPECIFIED);
+
+    if (!p) {
+        return ret;
+    }
+
+    ret.iova = va;
+    ret.translated_addr = pagemap_virt_to_phys_fd(bd->pagemap_fd, p);
+    ret.perm = IOMMU_ACCESS_FLAG(prot & VIRTIO_MSG_IOMMU_PROT_READ,
+                                 prot & VIRTIO_MSG_IOMMU_PROT_WRITE);
+
+    address_space_unmap(&address_space_memory, p, plen,
+                        prot & VIRTIO_MSG_IOMMU_PROT_WRITE,
+                        0);
+
+//    printf("%s: %lx.%lx  ->  %lx\n", __func__, va, ret.iova, ret.translated_addr);
+    return ret;
+}
+
+
+bool virtio_msg_bus_connect(BusState *bus,
+                            const VirtIOMSGBusPort *port,
+                            void *opaque)
+{
+    VirtIOMSGBusDevice *bd = virtio_msg_bus_get_device(bus);
+    if (!bd) {
+        /* Nothing connected to this virtio-msg device. Ignore. */
+        return false;
+    }
+
+    bd->peer = port;
+    bd->opaque = opaque;
+    return true;
+}
+
+static inline void virtio_msg_bus_ooo_enqueue(VirtIOMSGBusDevice *bd,
+                                              VirtIOMSG *msg)
+{
+    /* TODO: Add support for wrapping the queue.  */
+    assert(bd->ooo_queue.num < ARRAY_SIZE(bd->ooo_queue.msg));
+    bd->ooo_queue.msg[bd->ooo_queue.num++] = *msg;
+}
+
+void virtio_msg_bus_ooo_process(VirtIOMSGBusDevice *bd)
+{
+    while (bd->ooo_queue.pos < bd->ooo_queue.num) {
+        int pos = bd->ooo_queue.pos++;
+        virtio_msg_bus_receive(bd, &bd->ooo_queue.msg[pos]);
+    }
+    bd->ooo_queue.num = 0;
+    bd->ooo_queue.pos = 0;
+}
+
+void virtio_msg_bus_ooo_receive(VirtIOMSGBusDevice *bd,
+                                VirtIOMSG *msg_req,
+                                VirtIOMSG *msg_resp)
+{
+    /*
+     * Event notifications are posted and shouldn't be handled immediately
+     * because they may trigger additional recursive requests further
+     * further complicating the situation.
+     *
+     * Instead, queue events and wait for the notification path to re-trigger
+     * processing of messages and process the OOO queue there.
+     */
+    if (msg_resp->id == VIRTIO_MSG_EVENT_AVAIL ||
+            msg_resp->id == VIRTIO_MSG_EVENT_USED ||
+            msg_resp->id == VIRTIO_MSG_EVENT_CONFIG) {
+        virtio_msg_bus_ooo_enqueue(bd, msg_resp);
+    } else {
+        virtio_msg_bus_receive(bd, msg_resp);
+    }
+}
+
+void virtio_msg_bus_process(VirtIOMSGBusDevice *bd)
+{
+    VirtIOMSGBusDeviceClass *bdc;
+    bdc = VIRTIO_MSG_BUS_DEVICE_CLASS(object_get_class(OBJECT(bd)));
+
+    virtio_msg_bus_ooo_process(bd);
+    bdc->process(bd);
+}
+
+int virtio_msg_bus_send(BusState *bus,
+                        VirtIOMSG *msg_req,
+                        VirtIOMSG *msg_resp)
+{
+    VirtIOMSGBusDeviceClass *bdc;
+    int r = VIRTIO_MSG_NO_ERROR;
+
+    VirtIOMSGBusDevice *bd = virtio_msg_bus_get_device(bus);
+    bdc = VIRTIO_MSG_BUS_DEVICE_CLASS(object_get_class(OBJECT(bd)));
+
+    if (bdc->send) {
+        r = bdc->send(bd, msg_req, msg_resp);
+    }
+    return r;
+}
+
+static void virtio_msg_bus_device_realize(DeviceState *dev, Error **errp)
+{
+    VirtIOMSGBusDevice *bd = VIRTIO_MSG_BUS_DEVICE(dev);
+
+    bd->pagemap_fd = -1;
+    bd->virt2gfn_fd = -1;
+}
+
+static void virtio_msg_bus_class_init(ObjectClass *klass, void *data)
+{
+    BusClass *bc = BUS_CLASS(klass);
+
+    /*
+    bc->print_dev = sysbus_dev_print;
+    bc->get_fw_dev_path = sysbus_get_fw_dev_path;
+    */
+    bc->max_dev = 1;
+}
+
+static const TypeInfo virtio_msg_bus_info = {
+    .name = TYPE_VIRTIO_MSG_BUS,
+    .parent = TYPE_BUS,
+    .instance_size = sizeof(BusState),
+    .class_init = virtio_msg_bus_class_init,
+};
+
+static void virtio_msg_bus_device_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *k = DEVICE_CLASS(klass);
+
+    k->realize = virtio_msg_bus_device_realize;
+    k->bus_type = TYPE_VIRTIO_MSG_BUS;
+}
+
+static const TypeInfo virtio_msg_bus_device_type_info = {
+    .name = TYPE_VIRTIO_MSG_BUS_DEVICE,
+    .parent = TYPE_DEVICE,
+    .instance_size = sizeof(VirtIOMSGBusDevice),
+    .abstract = true,
+    .class_size = sizeof(VirtIOMSGBusDeviceClass),
+    .class_init = virtio_msg_bus_device_class_init,
+};
+
+static void virtio_msg_bus_register_types(void)
+{
+    type_register_static(&virtio_msg_bus_info);
+    type_register_static(&virtio_msg_bus_device_type_info);
+}
+
+type_init(virtio_msg_bus_register_types)
diff --git a/hw/virtio/virtio-msg-machine.c b/hw/virtio/virtio-msg-machine.c
new file mode 100644
index 0000000000..e1c31041f8
--- /dev/null
+++ b/hw/virtio/virtio-msg-machine.c
@@ -0,0 +1,51 @@
+#include "qemu/osdep.h"
+
+#include "exec/memory.h"
+#include "qapi/error.h"
+#include "hw/qdev-core.h"
+#include "sysemu/dma.h"
+#include "hw/virtio/virtio-msg-machine.h"
+
+static void virtio_msg_machine_init(MachineState *machine)
+{
+    VirtIOMSGMachineState *s = VIRTIO_MSG_MACHINE(machine);
+    int i;
+
+    /* FIXME: Why is this backend a Sysbus dev?  */
+    for (i = 0; i < ARRAY_SIZE(s->backends); i++) {
+        object_initialize_child(OBJECT(s), "backend[*]", &s->backends[i],
+                                TYPE_VIRTIO_MSG);
+        sysbus_realize(SYS_BUS_DEVICE(&s->backends[i]), &error_fatal);
+    }
+}
+
+static void virtio_msg_machine_instance_init(Object *obj)
+{
+}
+
+static void virtio_msg_machine_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->init = virtio_msg_machine_init;
+    mc->desc = "Experimental virtio-msg machine";
+}
+
+static const TypeInfo virtio_msg_machine = {
+    .name = TYPE_VIRTIO_MSG_MACHINE,
+    .parent = TYPE_MACHINE,
+    .instance_size = sizeof(VirtIOMSGMachineState),
+    .instance_init = virtio_msg_machine_instance_init,
+    .class_init = virtio_msg_machine_class_init,
+    .interfaces = (InterfaceInfo[]) {
+        { TYPE_HOTPLUG_HANDLER },
+        { }
+    }
+};
+
+static void virtio_msg_machine_register_types(void)
+{
+    type_register_static(&virtio_msg_machine);
+}
+
+type_init(virtio_msg_machine_register_types);
diff --git a/hw/virtio/virtio-msg-proxy-driver-pci.c b/hw/virtio/virtio-msg-proxy-driver-pci.c
new file mode 100644
index 0000000000..49f977ba88
--- /dev/null
+++ b/hw/virtio/virtio-msg-proxy-driver-pci.c
@@ -0,0 +1,92 @@
+/*
+ * Virtio msg driver PCI Bindings
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/virtio/virtio-pci.h"
+#include "hw/virtio/virtio-msg-proxy-driver.h"
+#include "hw/qdev-properties.h"
+#include "qapi/error.h"
+#include "qemu/module.h"
+#include "qom/object.h"
+
+typedef struct VirtIOMSGProxyDriverPCI VirtIOMSGProxyDriverPCI;
+
+#define TYPE_VIRTIO_MSG_PROXY_DRIVER_PCI "virtio-msg-proxy-driver-base"
+DECLARE_INSTANCE_CHECKER(VirtIOMSGProxyDriverPCI, VIRTIO_MSG_PROXY_DRIVER_PCI,
+                         TYPE_VIRTIO_MSG_PROXY_DRIVER_PCI)
+
+struct VirtIOMSGProxyDriverPCI {
+    VirtIOPCIProxy parent_obj;
+    VirtIOMSGProxyDriver vdev;
+};
+
+static Property virtio_mpd_properties[] = {
+    DEFINE_PROP_BIT("ioeventfd", VirtIOPCIProxy, flags,
+                    VIRTIO_PCI_FLAG_USE_IOEVENTFD_BIT, true),
+    DEFINE_PROP_UINT32("vectors", VirtIOPCIProxy, nvectors,
+                       DEV_NVECTORS_UNSPECIFIED),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_mpd_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
+{
+    VirtIOMSGProxyDriverPCI *vrng = VIRTIO_MSG_PROXY_DRIVER_PCI(vpci_dev);
+    DeviceState *vdev = DEVICE(&vrng->vdev);
+
+    if (vpci_dev->nvectors == DEV_NVECTORS_UNSPECIFIED) {
+        vpci_dev->nvectors = 2;
+    }
+
+    if (!qdev_realize(vdev, BUS(&vpci_dev->bus), errp)) {
+        return;
+    }
+}
+
+static void virtio_mpd_pci_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioPCIClass *k = VIRTIO_PCI_CLASS(klass);
+    PCIDeviceClass *pcidev_k = PCI_DEVICE_CLASS(klass);
+
+    k->realize = virtio_mpd_pci_realize;
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+
+    pcidev_k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;
+    /* FIXME!!!! */
+    pcidev_k->device_id = PCI_DEVICE_ID_VIRTIO_NET;
+    pcidev_k->revision = VIRTIO_PCI_ABI_VERSION;
+    pcidev_k->class_id = PCI_CLASS_OTHERS;
+    device_class_set_props(dc, virtio_mpd_properties);
+}
+
+static void virtio_mpd_initfn(Object *obj)
+{
+    VirtIOMSGProxyDriverPCI *dev = VIRTIO_MSG_PROXY_DRIVER_PCI(obj);
+
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_MSG_PROXY_DRIVER);
+}
+
+static const VirtioPCIDeviceTypeInfo virtio_mpd_pci_info = {
+    .base_name             = TYPE_VIRTIO_MSG_PROXY_DRIVER_PCI,
+    .generic_name          = "virtio-msg-proxy-driver-pci",
+    .transitional_name     = "virtio-msg-proxy-driver-pci-transitional",
+    .non_transitional_name = "virtio-msg-proxy-driver-pci-non-transitional",
+    .instance_size = sizeof(VirtIOMSGProxyDriverPCI),
+    .instance_init = virtio_mpd_initfn,
+    .class_init    = virtio_mpd_pci_class_init,
+};
+
+static void virtio_mpd_pci_register(void)
+{
+    virtio_pci_types_register(&virtio_mpd_pci_info);
+}
+
+type_init(virtio_mpd_pci_register)
diff --git a/hw/virtio/virtio-msg-proxy-driver.c b/hw/virtio/virtio-msg-proxy-driver.c
new file mode 100644
index 0000000000..78d847c27b
--- /dev/null
+++ b/hw/virtio/virtio-msg-proxy-driver.c
@@ -0,0 +1,346 @@
+/*
+ * VirtIO MSG proxy driver.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu/iov.h"
+#include "qemu/module.h"
+#include "qemu/timer.h"
+#include "qemu/error-report.h"
+#include "hw/virtio/virtio.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio-msg-bus.h"
+#include "hw/virtio/virtio-msg-prot.h"
+#include "hw/virtio/virtio-msg-proxy-driver.h"
+
+#include "standard-headers/linux/virtio_ids.h"
+
+static void vmpd_handle_output(VirtIODevice *vdev, VirtQueue *vq)
+{
+    VirtIOMSGProxyDriver *vpd = VIRTIO_MSG_PROXY_DRIVER(vdev);
+    uint32_t index = virtio_get_queue_index(vq);
+    VirtIOMSG msg;
+
+    virtio_msg_pack_event_avail(&msg, index, 0, 0);
+    virtio_msg_bus_send(&vpd->bus, &msg, NULL);
+}
+
+static bool vmpd_probe_queue(VirtIOMSGProxyDriver *vpd, int i)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(vpd);
+    VirtIOMSG msg, msg_resp;
+
+    virtio_msg_pack_get_vqueue(&msg, i);
+    virtio_msg_bus_send(&vpd->bus, &msg, &msg_resp);
+
+    if (msg_resp.get_vqueue_resp.max_size) {
+        virtio_add_queue(vdev, msg_resp.get_vqueue_resp.max_size,
+                         vmpd_handle_output);
+    }
+
+    return msg_resp.get_vqueue_resp.max_size != 0;
+}
+
+static void vmpd_probe_queues(VirtIOMSGProxyDriver *vpd)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(vpd);
+    int i;
+
+    /* First, delete all queues.  */
+    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {
+        if (!virtio_queue_get_num(vdev, i)) {
+            break;
+        }
+        virtio_del_queue(vdev, i);
+    }
+
+    /* And start re-adding active queue's from the peer.  */
+    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {
+        if (!vmpd_probe_queue(vpd, i)) {
+            break;
+        }
+    }
+}
+
+static void vmpd_event_used(VirtIOMSGProxyDriver *vpd,
+                           VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(vpd);
+    VirtQueue *vq;
+
+    vq = virtio_get_queue(vdev, msg->event_used.index);
+    virtio_notify_force(vdev, vq);
+}
+
+static void vmpd_event_config(VirtIOMSGProxyDriver *vpd,
+                             VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(vpd);
+
+    vdev->status = msg->event_config.status;
+    virtio_notify_config(vdev);
+}
+
+static void vmpd_iommu_translate(VirtIOMSGProxyDriver *vpd,
+                                VirtIOMSG *msg)
+{
+    uint8_t prot = msg->iommu_translate.prot;
+    uint64_t va = msg->iommu_translate.va;
+    VirtIOMSG msg_resp;
+    IOMMUTLBEntry r;
+
+    r = virtio_msg_bus_iommu_translate(&vpd->bus, va, prot);
+    prot = r.perm & IOMMU_RO ? VIRTIO_MSG_IOMMU_PROT_READ : 0;
+    prot |= r.perm & IOMMU_WO ? VIRTIO_MSG_IOMMU_PROT_WRITE : 0;
+
+    virtio_msg_pack_iommu_translate_resp(&msg_resp,
+                                         r.iova, r.translated_addr,
+                                         prot);
+    virtio_msg_bus_send(&vpd->bus, &msg_resp, NULL);
+}
+
+/* FIXME: Avoid duplication.  */
+typedef void (*VirtIOMSGHandler)(VirtIOMSGProxyDriver *vpd,
+                                 VirtIOMSG *msg);
+
+static const VirtIOMSGHandler msg_handlers[] = {
+    [VIRTIO_MSG_EVENT_USED] = vmpd_event_used,
+    [VIRTIO_MSG_EVENT_CONFIG] = vmpd_event_config,
+    [VIRTIO_MSG_IOMMU_TRANSLATE] = vmpd_iommu_translate,
+};
+
+static int vmpd_receive_msg(VirtIOMSGBusDevice *bd, VirtIOMSG *msg)
+{
+    VirtIOMSGProxyDriver *vpd = VIRTIO_MSG_PROXY_DRIVER(bd->opaque);
+    VirtIOMSGHandler handler;
+
+    //virtio_msg_print(msg);
+    assert((msg->type & VIRTIO_MSG_TYPE_RESPONSE) == 0);
+
+    if (msg->id > ARRAY_SIZE(msg_handlers)) {
+        return VIRTIO_MSG_ERROR_UNSUPPORTED_MESSAGE_ID;
+    }
+
+    handler = msg_handlers[msg->id];
+    if (handler) {
+        handler(vpd, msg);
+    }
+
+    return VIRTIO_MSG_NO_ERROR;
+}
+
+static const VirtIOMSGBusPort vmpd_port = {
+    .receive = vmpd_receive_msg,
+    .is_driver = true
+};
+
+static uint64_t vmpd_get_features(VirtIODevice *vdev, uint64_t f, Error **errp)
+{
+    VirtIOMSGProxyDriver *vpd = VIRTIO_MSG_PROXY_DRIVER(vdev);
+    VirtIOMSG msg, msg_resp;
+
+    if (virtio_msg_bus_connected(&vpd->bus)) {
+        virtio_msg_pack_get_features(&msg, 0);
+        virtio_msg_bus_send(&vpd->bus, &msg, &msg_resp);
+
+        f = msg_resp.get_features_resp.features;
+    }
+
+    return f;
+}
+
+static void vmpd_set_features(VirtIODevice *vdev, uint64_t f)
+{
+    VirtIOMSGProxyDriver *vpd = VIRTIO_MSG_PROXY_DRIVER(vdev);
+    VirtIOMSG msg, msg_resp;
+
+    virtio_msg_pack_set_features(&msg, 0, f);
+    virtio_msg_bus_send(&vpd->bus, &msg, &msg_resp);
+}
+
+static void vmpd_set_status(VirtIODevice *vdev, uint8_t status)
+{
+    VirtIOMSGProxyDriver *vpd = VIRTIO_MSG_PROXY_DRIVER(vdev);
+    VirtIOMSG msg, msg_resp;
+
+    if (!vdev->vm_running) {
+        return;
+    }
+
+    /*
+     * We need to update our view of available queue's from
+     * the peer after feature negotiation. This is because:
+     *
+     * Guests will first feature negotiate and then setup queues.
+     * Setting up the queues involves checking which queues are enabled
+     * by checking for non-zero virtio_queue_get_num(vdev, queue_index).
+     *
+     * When the guest queries for the max size over virtio-mmio or
+     * virtio-pci, QEMU will simply return the local view of
+     * virtio_queue_get_num(), which may get updated during feature
+     * negotiation (see virtio-net mq support for an example).
+     */
+    if (status & VIRTIO_CONFIG_S_FEATURES_OK) {
+        vmpd_probe_queues(vpd);
+    }
+
+    virtio_msg_pack_set_device_status(&msg, status);
+    virtio_msg_bus_send(&vpd->bus, &msg, NULL);
+
+    virtio_msg_pack_get_device_status(&msg);
+    virtio_msg_bus_send(&vpd->bus, &msg, &msg_resp);
+
+    vdev->status = msg_resp.get_device_status_resp.status;
+}
+
+static uint32_t vmpd_read_config(VirtIODevice *vdev,
+                                          int size, uint32_t addr)
+{
+    VirtIOMSGProxyDriver *vpd = VIRTIO_MSG_PROXY_DRIVER(vdev);
+    VirtIOMSG msg, msg_resp;
+
+    virtio_msg_pack_get_config(&msg, size, addr);
+    virtio_msg_bus_send(&vpd->bus, &msg, &msg_resp);
+
+    return msg_resp.get_config_resp.data;
+}
+
+static void vmpd_write_config(VirtIODevice *vdev,
+                                      int size, uint32_t addr, uint32_t val)
+{
+    VirtIOMSGProxyDriver *vpd = VIRTIO_MSG_PROXY_DRIVER(vdev);
+    VirtIOMSG msg, msg_resp;
+
+    virtio_msg_pack_set_config(&msg, size, addr, val);
+    virtio_msg_bus_send(&vpd->bus, &msg, &msg_resp);
+}
+
+static void vmpd_queue_enable(VirtIODevice *vdev, uint32_t n)
+{
+    VirtIOMSGProxyDriver *vpd = VIRTIO_MSG_PROXY_DRIVER(vdev);
+    VirtIOMSG msg;
+    uint64_t descriptor_addr = virtio_queue_get_addr(vdev, n);
+    uint64_t driver_addr = virtio_queue_get_avail_addr(vdev, n);
+    uint64_t device_addr = virtio_queue_get_used_addr(vdev, n);
+    uint32_t size = virtio_queue_get_num(vdev, n);
+
+    virtio_msg_pack_set_vqueue(&msg, n, size,
+                               descriptor_addr,
+                               driver_addr,
+                               device_addr);
+    virtio_msg_bus_send(&vpd->bus, &msg, NULL);
+}
+
+static void vmpd_reset_hold(Object *obj)
+{
+    VirtIOMSGProxyDriver *vpd = VIRTIO_MSG_PROXY_DRIVER(obj);
+    VirtIODevice *vdev = VIRTIO_DEVICE(vpd);
+    VirtIOMSGBusDevice *bd;
+    VirtIOMSG msg, msg_resp;
+
+    if (!virtio_msg_bus_connect(&vpd->bus, &vmpd_port, vpd)) {
+        error_report("virtio-msg-proxy: Failed to connect!");
+        exit(EXIT_FAILURE);
+    }
+
+    virtio_msg_pack_get_device_info(&msg);
+    virtio_msg_bus_send(&vpd->bus, &msg, &msg_resp);
+
+    if (vpd->cfg.virtio_id != msg_resp.get_device_info_resp.device_id) {
+        error_report("virtio-msg-proxy: Device-id missmatch! %x != %x",
+                     msg_resp.get_device_info_resp.device_id,
+                     vpd->cfg.virtio_id);
+        exit(EXIT_FAILURE);
+    }
+
+    /* Update host features.  */
+    vdev->host_features = vmpd_get_features(vdev, vdev->host_features,
+                                            &error_abort);
+
+    bd = virtio_msg_bus_get_device(&vpd->bus);
+
+    if (bd->iommu_translate) {
+        virtio_msg_pack_iommu_enable(&msg, true);
+        virtio_msg_bus_send(&vpd->bus, &msg, NULL);
+    }
+
+    vmpd_probe_queues(vpd);
+}
+
+static void vmpd_device_realize(DeviceState *dev, Error **errp)
+{
+    VirtIOMSGProxyDriver *vpd = VIRTIO_MSG_PROXY_DRIVER(dev);
+    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+
+    qbus_init(&vpd->bus, sizeof(vpd->bus), TYPE_VIRTIO_MSG_BUS, dev, NULL);
+
+    /* TODO: Figure out a way to read this from the peer.  */
+    virtio_init(vdev, vpd->cfg.virtio_id, 0);
+}
+
+static void vmpd_device_unrealize(DeviceState *dev)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+
+    virtio_del_queue(vdev, 0);
+    virtio_cleanup(vdev);
+}
+
+static const VMStateDescription vmstate_virtio_msg_pd = {
+    .name = "virtio-msg-proxy-driver",
+    .minimum_version_id = 1,
+    .version_id = 1,
+    .fields = (const VMStateField[]) {
+        VMSTATE_VIRTIO_DEVICE,
+        VMSTATE_END_OF_LIST()
+    },
+};
+
+static Property vmpd_properties[] = {
+    DEFINE_PROP_UINT16("virtio-id", VirtIOMSGProxyDriver, cfg.virtio_id,
+                       VIRTIO_ID_NET),
+    DEFINE_PROP_BOOL("iommu-enable", VirtIOMSGProxyDriver,
+                     cfg.iommu_enable, false),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void vmpd_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
+    ResettableClass *rc = RESETTABLE_CLASS(klass);
+
+    device_class_set_props(dc, vmpd_properties);
+    dc->vmsd = &vmstate_virtio_msg_pd;
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+
+    rc->phases.hold  = vmpd_reset_hold;
+
+    vdc->realize = vmpd_device_realize;
+    vdc->unrealize = vmpd_device_unrealize;
+    vdc->get_features = vmpd_get_features;
+    vdc->set_features = vmpd_set_features;
+    vdc->set_status = vmpd_set_status;
+    vdc->read_config = vmpd_read_config;
+    vdc->write_config = vmpd_write_config;
+    vdc->queue_enable = vmpd_queue_enable;
+}
+
+static const TypeInfo vmpd_info = {
+    .name = TYPE_VIRTIO_MSG_PROXY_DRIVER,
+    .parent = TYPE_VIRTIO_DEVICE,
+    .instance_size = sizeof(VirtIOMSGProxyDriver),
+    .class_init = vmpd_class_init,
+};
+
+static void virtio_register_types(void)
+{
+    type_register_static(&vmpd_info);
+}
+
+type_init(virtio_register_types)
diff --git a/hw/virtio/virtio-msg.c b/hw/virtio/virtio-msg.c
new file mode 100644
index 0000000000..61f04e156a
--- /dev/null
+++ b/hw/virtio/virtio-msg.c
@@ -0,0 +1,516 @@
+/*
+ * Virtio MSG bindings
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>.
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "sysemu/dma.h"
+#include "qapi/error.h"
+#include "hw/irq.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio.h"
+#include "hw/virtio/virtio-msg-bus.h"
+#include "hw/virtio/virtio-msg.h"
+#include "qemu/error-report.h"
+#include "qemu/log.h"
+#include "trace.h"
+
+#define TYPE_VIRTIO_MSG_IOMMU_MEMORY_REGION "virtio-msg-iommu-memory-region"
+
+static void virtio_msg_device_info(VirtIOMSGProxy *s,
+                                   VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+    VirtIOMSG msg_resp;
+
+    virtio_msg_pack_get_device_info_resp(&msg_resp,
+                                         VIRTIO_MSG_DEVICE_VERSION,
+                                         vdev->device_id,
+                                         VIRTIO_MSG_VENDOR_ID);
+    virtio_msg_bus_send(&s->msg_bus, &msg_resp, NULL);
+}
+
+static void virtio_msg_get_features(VirtIOMSGProxy *s,
+                                    VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+    VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(vdev);
+    VirtIOMSG msg_resp;
+    uint64_t features;
+
+    /*
+     * The peer's host_features shouldn't matter here. When we're
+     * connected to a QEMU proxy, we need to advertise our local
+     * host features and not anything provided by the proxy.
+     */
+    features = vdc->get_features(vdev, vdev->host_features, &error_abort);
+
+    virtio_msg_pack_get_features_resp(&msg_resp, 0, features);
+    virtio_msg_bus_send(&s->msg_bus, &msg_resp, NULL);
+}
+
+static void virtio_msg_set_features(VirtIOMSGProxy *s,
+                                    VirtIOMSG *msg)
+{
+    VirtIOMSG msg_resp;
+
+    s->guest_features = msg->set_features.features;
+
+    virtio_msg_pack_set_features_resp(&msg_resp, 0, s->guest_features);
+    virtio_msg_bus_send(&s->msg_bus, &msg_resp, NULL);
+}
+
+static void virtio_msg_soft_reset(VirtIOMSGProxy *s)
+{
+    virtio_bus_reset(&s->bus);
+    s->guest_features = 0;
+}
+
+static void virtio_msg_set_device_status(VirtIOMSGProxy *s,
+                                         VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+    uint32_t status = msg->set_device_status.status;
+
+    printf("set_device_status: %x %x\n", status, vdev->status);
+
+    if (!(status & VIRTIO_CONFIG_S_DRIVER_OK)) {
+        virtio_bus_stop_ioeventfd(&s->bus);
+    }
+
+    if (status & VIRTIO_CONFIG_S_FEATURES_OK) {
+        virtio_set_features(vdev, s->guest_features);
+    }
+
+    virtio_set_status(vdev, status);
+    assert(vdev->status == status);
+
+    if (status & VIRTIO_CONFIG_S_DRIVER_OK) {
+        virtio_bus_start_ioeventfd(&s->bus);
+    }
+
+    if (status == 0) {
+        virtio_msg_soft_reset(s);
+    }
+}
+
+static void virtio_msg_get_device_status(VirtIOMSGProxy *s,
+                                         VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+    VirtIOMSG msg_resp;
+
+    virtio_msg_pack_get_device_status_resp(&msg_resp, vdev->status);
+    virtio_msg_print(&msg_resp);
+    virtio_msg_bus_send(&s->msg_bus, &msg_resp, NULL);
+}
+
+static void virtio_msg_get_config(VirtIOMSGProxy *s,
+                                  VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+    uint8_t size = msg->get_config.size;
+    uint32_t offset = msg->get_config.offset;
+    uint64_t data;
+    VirtIOMSG msg_resp;
+
+    /* Add the 3rd byte of offset.  */
+    offset += msg->get_config.offset_msb << 16;
+
+    switch (size) {
+    case 4:
+        data = virtio_config_modern_readl(vdev, offset);
+        break;
+    case 2:
+        data = virtio_config_modern_readw(vdev, offset);
+        break;
+    case 1:
+        data = virtio_config_modern_readb(vdev, offset);
+        break;
+    default:
+        g_assert_not_reached();
+        break;
+    }
+
+    virtio_msg_pack_get_config_resp(&msg_resp, size, offset, data);
+    virtio_msg_bus_send(&s->msg_bus, &msg_resp, NULL);
+}
+
+static void virtio_msg_set_config(VirtIOMSGProxy *s,
+                                  VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+    uint8_t size = msg->set_config.size;
+    uint32_t offset = msg->set_config.offset;
+    uint64_t data = msg->set_config.data;
+    VirtIOMSG msg_resp;
+
+    /* Add the 3rd byte of offset.  */
+    offset += msg->set_config.offset_msb << 16;
+
+    switch (size) {
+    case 4:
+        virtio_config_modern_writel(vdev, offset, data);
+        break;
+    case 2:
+        virtio_config_modern_writew(vdev, offset, data);
+        break;
+    case 1:
+        virtio_config_modern_writeb(vdev, offset, data);
+        break;
+    default:
+        g_assert_not_reached();
+        break;
+    }
+
+    virtio_msg_pack_set_config_resp(&msg_resp, size, offset, data);
+    virtio_msg_bus_send(&s->msg_bus, &msg_resp, NULL);
+}
+
+static void virtio_msg_get_config_gen(VirtIOMSGProxy *s,
+                                      VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+    VirtIOMSG msg_resp;
+
+    virtio_msg_pack_get_config_gen_resp(&msg_resp, vdev->generation);
+    virtio_msg_bus_send(&s->msg_bus, &msg_resp, NULL);
+}
+
+static void virtio_msg_get_vqueue(VirtIOMSGProxy *s,
+                                  VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+    VirtIOMSG msg_resp;
+    uint32_t max_size = VIRTQUEUE_MAX_SIZE;
+    uint32_t index = msg->get_vqueue.index;
+
+    if (!virtio_queue_get_num(vdev, index)) {
+        max_size = 0;
+    }
+
+    virtio_msg_pack_get_vqueue_resp(&msg_resp, index, max_size);
+    virtio_msg_bus_send(&s->msg_bus, &msg_resp, NULL);
+}
+
+static void virtio_msg_set_vqueue(VirtIOMSGProxy *s,
+                                  VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+
+    virtio_queue_set_num(vdev, msg->set_vqueue.index, msg->set_vqueue.size);
+    virtio_queue_set_rings(vdev, msg->set_vqueue.index,
+                           msg->set_vqueue.descriptor_addr,
+                           msg->set_vqueue.driver_addr,
+                           msg->set_vqueue.device_addr);
+    virtio_queue_enable(vdev, vdev->queue_sel);
+}
+
+static void virtio_msg_event_avail(VirtIOMSGProxy *s,
+                                   VirtIOMSG *msg)
+{
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+
+    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {
+        VirtIOMSG msg_ev;
+
+        virtio_error(vdev, "Notification while driver not OK?");
+        virtio_msg_pack_event_config(&msg_ev, vdev->status,
+                                     0, 0, NULL);
+        virtio_msg_bus_send(&s->msg_bus, &msg_ev, NULL);
+        return;
+    }
+    virtio_queue_notify(vdev, msg->event_avail.index);
+}
+
+static void virtio_msg_iommu_enable(VirtIOMSGProxy *s,
+                                    VirtIOMSG *msg)
+{
+    s->iommu_enabled = msg->iommu_enable.enable;
+}
+
+typedef void (*VirtIOMSGHandler)(VirtIOMSGProxy *s,
+                                 VirtIOMSG *msg);
+
+static const VirtIOMSGHandler msg_handlers[] = {
+    [VIRTIO_MSG_DEVICE_INFO] = virtio_msg_device_info,
+    [VIRTIO_MSG_GET_FEATURES] = virtio_msg_get_features,
+    [VIRTIO_MSG_SET_FEATURES] = virtio_msg_set_features,
+    [VIRTIO_MSG_GET_DEVICE_STATUS] = virtio_msg_get_device_status,
+    [VIRTIO_MSG_SET_DEVICE_STATUS] = virtio_msg_set_device_status,
+    [VIRTIO_MSG_GET_CONFIG] = virtio_msg_get_config,
+    [VIRTIO_MSG_SET_CONFIG] = virtio_msg_set_config,
+    [VIRTIO_MSG_GET_CONFIG_GEN] = virtio_msg_get_config_gen,
+    [VIRTIO_MSG_GET_VQUEUE] = virtio_msg_get_vqueue,
+    [VIRTIO_MSG_SET_VQUEUE] = virtio_msg_set_vqueue,
+    [VIRTIO_MSG_EVENT_AVAIL] = virtio_msg_event_avail,
+    [VIRTIO_MSG_IOMMU_ENABLE] = virtio_msg_iommu_enable,
+};
+
+static int virtio_msg_receive_msg(VirtIOMSGBusDevice *bd, VirtIOMSG *msg)
+{
+    VirtIOMSGProxy *s = VIRTIO_MSG(bd->opaque);
+    VirtIOMSGHandler handler;
+
+    //virtio_msg_print(msg);
+    if (msg->id > ARRAY_SIZE(msg_handlers)) {
+        return VIRTIO_MSG_ERROR_UNSUPPORTED_MESSAGE_ID;
+    }
+
+    handler = msg_handlers[msg->id];
+    assert((msg->type & VIRTIO_MSG_TYPE_RESPONSE) == 0);
+
+    if (handler) {
+        handler(s, msg);
+    }
+
+    return VIRTIO_MSG_NO_ERROR;
+}
+
+static const VirtIOMSGBusPort virtio_msg_port = {
+    .receive = virtio_msg_receive_msg,
+    .is_driver = false
+};
+
+static void virtio_msg_notify_queue(DeviceState *opaque, uint16_t index)
+{
+    VirtIOMSGProxy *s = VIRTIO_MSG(opaque);
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+    VirtIOMSG msg;
+
+    if (!vdev || !virtio_msg_bus_connected(&s->msg_bus)) {
+        return;
+    }
+
+    virtio_msg_pack_event_used(&msg, index);
+    virtio_msg_bus_send(&s->msg_bus, &msg, NULL);
+}
+
+static void virtio_msg_notify(DeviceState *opaque, uint16_t vector)
+{
+    VirtIOMSGProxy *s = VIRTIO_MSG(opaque);
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+    VirtIOMSG msg;
+
+    if (!virtio_msg_bus_connected(&s->msg_bus)) {
+        return;
+    }
+
+    /* Check if we're notifying for VQ or CONFIG updates.  */
+    if (vdev->isr & 2) {
+        virtio_msg_pack_event_config(&msg, vdev->status, 0, 0, NULL);
+        virtio_msg_bus_send(&s->msg_bus, &msg, NULL);
+    }
+}
+
+static const VMStateDescription vmstate_virtio_msg_state_sub = {
+    .name = "virtio_msg_device",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (const VMStateField[]) {
+        VMSTATE_UINT64(guest_features, VirtIOMSGProxy),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static const VMStateDescription vmstate_virtio_msg = {
+    .name = "virtio_msg_proxy_backend",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (const VMStateField[]) {
+        VMSTATE_END_OF_LIST()
+    },
+    .subsections = (const VMStateDescription * const []) {
+        &vmstate_virtio_msg_state_sub,
+        NULL
+    }
+};
+
+static void virtio_msg_save_extra_state(DeviceState *opaque, QEMUFile *f)
+{
+    VirtIOMSGProxy *s = VIRTIO_MSG(opaque);
+
+    vmstate_save_state(f, &vmstate_virtio_msg, s, NULL);
+}
+
+static int virtio_msg_load_extra_state(DeviceState *opaque, QEMUFile *f)
+{
+    VirtIOMSGProxy *s = VIRTIO_MSG(opaque);
+
+    return vmstate_load_state(f, &vmstate_virtio_msg, s, 1);
+}
+
+static bool virtio_msg_has_extra_state(DeviceState *opaque)
+{
+    return true;
+}
+
+static void virtio_msg_reset_hold(Object *obj)
+{
+    VirtIOMSGProxy *s = VIRTIO_MSG(obj);
+    bool r;
+
+    virtio_msg_soft_reset(s);
+
+    r = virtio_msg_bus_connect(&s->msg_bus, &virtio_msg_port, s);
+    if (r) {
+        s->bus_as = virtio_msg_bus_get_remote_as(&s->msg_bus);
+    }
+}
+
+static void virtio_msg_pre_plugged(DeviceState *d, Error **errp)
+{
+    VirtIOMSGProxy *s = VIRTIO_MSG(d);
+    VirtIODevice *vdev = virtio_bus_get_device(&s->bus);
+
+    virtio_add_feature(&vdev->host_features, VIRTIO_F_VERSION_1);
+}
+
+static AddressSpace *virtio_msg_get_dma_as(DeviceState *d)
+{
+    VirtIOMSGProxy *s = VIRTIO_MSG(d);
+
+    return &s->dma_as;
+}
+
+static Property virtio_msg_properties[] = {
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_msg_realize(DeviceState *d, Error **errp)
+{
+    VirtIOMSGProxy *s = VIRTIO_MSG(d);
+
+    qbus_init(&s->bus, sizeof(s->bus),
+              TYPE_VIRTIO_MSG_PROXY_BUS, d, NULL);
+    qbus_init(&s->msg_bus, sizeof(s->msg_bus),
+              TYPE_VIRTIO_MSG_BUS, d, NULL);
+
+    memory_region_init_iommu(&s->mr_iommu, sizeof(s->mr_iommu),
+                             TYPE_VIRTIO_MSG_IOMMU_MEMORY_REGION,
+                             OBJECT(d), "virtio-msg-iommu", UINT64_MAX);
+    address_space_init(&s->dma_as, MEMORY_REGION(&s->mr_iommu), "dma");
+}
+
+static void virtio_msg_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    ResettableClass *rc = RESETTABLE_CLASS(klass);
+
+    dc->realize = virtio_msg_realize;
+    dc->user_creatable = true;
+    rc->phases.hold  = virtio_msg_reset_hold;
+
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    device_class_set_props(dc, virtio_msg_properties);
+}
+
+static const TypeInfo virtio_msg_info = {
+    .name          = TYPE_VIRTIO_MSG,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(VirtIOMSGProxy),
+    .class_init    = virtio_msg_class_init,
+};
+
+static IOMMUTLBEntry virtio_msg_iommu_translate(IOMMUMemoryRegion *iommu,
+                                                hwaddr addr,
+                                                IOMMUAccessFlags flags,
+                                                int iommu_idx)
+{
+    VirtIOMSGProxy *s = VIRTIO_MSG(container_of(iommu,
+                                                VirtIOMSGProxy, mr_iommu));
+    VirtIOMSG msg, msg_resp;
+    uint8_t prot;
+
+    IOMMUTLBEntry ret = {
+        .iova = addr & ~VIRTIO_MSG_IOMMU_PAGE_MASK,
+        .translated_addr = addr & ~VIRTIO_MSG_IOMMU_PAGE_MASK,
+        .addr_mask = VIRTIO_MSG_IOMMU_PAGE_MASK,
+        .perm = IOMMU_RW,
+        .target_as = s->bus_as,
+    };
+
+    if (!s->iommu_enabled) {
+        /* identity mapped.  */
+        return ret;
+    }
+
+    prot = flags & IOMMU_RO ? VIRTIO_MSG_IOMMU_PROT_READ : 0;
+    prot |= flags & IOMMU_WO ? VIRTIO_MSG_IOMMU_PROT_WRITE : 0;
+
+    virtio_msg_pack_iommu_translate(&msg, ret.iova, prot);
+    virtio_msg_bus_send(&s->msg_bus, &msg, &msg_resp);
+
+    ret.iova = msg_resp.iommu_translate_resp.va;
+    ret.translated_addr = msg_resp.iommu_translate_resp.pa;
+    prot = msg_resp.iommu_translate_resp.prot;
+    ret.perm = IOMMU_ACCESS_FLAG(prot & VIRTIO_MSG_IOMMU_PROT_READ,
+                                 prot & VIRTIO_MSG_IOMMU_PROT_WRITE);
+
+    return ret;
+}
+
+static char *virtio_msg_bus_get_dev_path(DeviceState *dev)
+{
+    BusState *virtio_msg_bus;
+    VirtIOMSGProxy *virtio_msg_proxy;
+    char *proxy_path;
+
+    virtio_msg_bus = qdev_get_parent_bus(dev);
+    virtio_msg_proxy = VIRTIO_MSG(virtio_msg_bus->parent);
+    proxy_path = qdev_get_dev_path(DEVICE(virtio_msg_proxy));
+
+    return proxy_path;
+}
+
+static void virtio_msg_bus_class_init(ObjectClass *klass, void *data)
+{
+    BusClass *bus_class = BUS_CLASS(klass);
+    VirtioBusClass *k = VIRTIO_BUS_CLASS(klass);
+
+    k->notify_queue = virtio_msg_notify_queue;
+    k->notify = virtio_msg_notify;
+    k->save_extra_state = virtio_msg_save_extra_state;
+    k->load_extra_state = virtio_msg_load_extra_state;
+    k->has_extra_state = virtio_msg_has_extra_state;
+    k->pre_plugged = virtio_msg_pre_plugged;
+    k->has_variable_vring_alignment = true;
+    k->get_dma_as = virtio_msg_get_dma_as;
+    bus_class->max_dev = 1;
+    bus_class->get_dev_path = virtio_msg_bus_get_dev_path;
+}
+
+static const TypeInfo virtio_msg_bus_info = {
+    .name          = TYPE_VIRTIO_MSG_PROXY_BUS,
+    .parent        = TYPE_VIRTIO_BUS,
+    .instance_size = sizeof(VirtioBusState),
+    .class_init    = virtio_msg_bus_class_init,
+};
+
+static void virtio_msg_iommu_memory_region_class_init(ObjectClass *klass,
+                                                      void *data)
+{
+    IOMMUMemoryRegionClass *imrc = IOMMU_MEMORY_REGION_CLASS(klass);
+
+    imrc->translate = virtio_msg_iommu_translate;
+}
+
+static const TypeInfo virtio_msg_iommu_info = {
+    .name = TYPE_VIRTIO_MSG_IOMMU_MEMORY_REGION,
+    .parent = TYPE_IOMMU_MEMORY_REGION,
+    .class_init = virtio_msg_iommu_memory_region_class_init,
+};
+
+static void virtio_msg_register_types(void)
+{
+    type_register_static(&virtio_msg_iommu_info);
+    type_register_static(&virtio_msg_bus_info);
+    type_register_static(&virtio_msg_info);
+}
+
+type_init(virtio_msg_register_types)
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index b066cdd4f1..e77408ce43 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -2076,10 +2076,12 @@ static int virtio_validate_features(VirtIODevice *vdev)
 
     if (virtio_host_has_feature(vdev, VIRTIO_F_IOMMU_PLATFORM) &&
         !virtio_vdev_has_feature(vdev, VIRTIO_F_IOMMU_PLATFORM)) {
+        printf("ERROR            platform mismatch!!!\n");
         return -EFAULT;
     }
 
     if (k->validate_features) {
+        printf("ERROR            features invalid!!!\n");
         return k->validate_features(vdev);
     } else {
         return 0;
@@ -2091,6 +2093,7 @@ int virtio_set_status(VirtIODevice *vdev, uint8_t val)
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     trace_virtio_set_status(vdev, val);
 
+    printf("%s: val %x\n", __func__, val);
     if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {
         if (!(vdev->status & VIRTIO_CONFIG_S_FEATURES_OK) &&
             val & VIRTIO_CONFIG_S_FEATURES_OK) {
@@ -2552,6 +2555,20 @@ static void virtio_irq(VirtQueue *vq)
 {
     virtio_set_isr(vq->vdev, 0x1);
     virtio_notify_vector(vq->vdev, vq->vector);
+
+}
+
+void virtio_notify_force(VirtIODevice *vdev, VirtQueue *vq)
+{
+    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
+    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
+
+    if (k->notify_queue) {
+        k->notify_queue(qbus->parent, virtio_get_queue_index(vq));
+    }
+
+    trace_virtio_notify(vdev, vq);
+    virtio_irq(vq);
 }
 
 void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)
@@ -2562,8 +2579,7 @@ void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)
         }
     }
 
-    trace_virtio_notify(vdev, vq);
-    virtio_irq(vq);
+    virtio_notify_force(vdev, vq);
 }
 
 void virtio_notify_config(VirtIODevice *vdev)
diff --git a/hw/xen/xen-operations.c b/hw/xen/xen-operations.c
index e00983ec44..654fb2536f 100644
--- a/hw/xen/xen-operations.c
+++ b/hw/xen/xen-operations.c
@@ -404,6 +404,28 @@ struct xenstore_backend_ops libxenstore_backend_ops = {
     .transaction_end = libxenstore_transaction_end,
 };
 
+int xc_domain_gfn2mfn(xc_interface *xch,
+                      uint32_t domid,
+                      uint64_t gfn,
+                      uint64_t *mfn,
+                      xenmem_access_t *access)
+{
+    struct xen_gfn2mfn xatp = {
+        .domid = domid,
+        .gfn = gfn,
+        .mfn = 0,
+        .access = 0,
+    };
+    int r;
+
+    r = xc_memory_op(xch, XENMEM_gfn2mfn, &xatp, sizeof(xatp));
+    if (r == 0) {
+        *mfn = xatp.mfn;
+        *access = xatp.access;
+    }
+    return r;
+}
+
 void setup_xen_backend_ops(void)
 {
 #if CONFIG_XEN_CTRL_INTERFACE_VERSION >= 40800
diff --git a/include/hw/virtio/pagemap.h b/include/hw/virtio/pagemap.h
new file mode 100644
index 0000000000..17a8ce308a
--- /dev/null
+++ b/include/hw/virtio/pagemap.h
@@ -0,0 +1,99 @@
+// Linux user-space virt-to-phys mapper
+
+// Copyright (c) 2024 Zero ASIC Corporation
+// This code is licensed under Apache License 2.0 (see LICENSE for details)
+
+#ifndef PAGEMAP_H_
+#define PAGEMAP_H_
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+/*
+ * From https://www.kernel.org/doc/Documentation/admin-guide/mm/pagemap.rst
+
+ * ``/proc/pid/pagemap``.  This file lets a userspace process find out which
+   physical frame each virtual page is mapped to.  It contains one 64-bit
+   value for each virtual page, containing the following data (from
+   ``fs/proc/task_mmu.c``, above pagemap_read):
+
+    * Bits 0-54  page frame number (PFN) if present
+    * Bits 0-4   swap type if swapped
+    * Bits 5-54  swap offset if swapped
+    * Bit  55    pte is soft-dirty (see
+      :ref:`Documentation/admin-guide/mm/soft-dirty.rst <soft_dirty>`)
+    * Bit  56    page exclusively mapped (since 4.2)
+    * Bit  57    pte is uffd-wp write-protected (since 5.13) (see
+      :ref:`Documentation/admin-guide/mm/userfaultfd.rst <userfaultfd>`)
+    * Bits 58-60 zero
+    * Bit  61    page is file-page or shared-anon (since 3.5)
+    * Bit  62    page swapped
+    * Bit  63    page present
+*/
+
+#define PAGEMAP_PFN_MASK ((1ULL << 55) - 1)
+#define PAGEMAP_PAGE_PRESENT (1ULL << 63)
+#define PAGEMAP_FAILED (~0ULL)
+
+static inline int pagemap_open_self(void) {
+    int r;
+
+    r = open("/proc/self/pagemap", O_RDONLY);
+    if (r < 0) {
+        perror("open");
+    }
+    return r;
+}
+
+// Translate a given virtual ptr into its physical address.
+static inline uint64_t pagemap_virt_to_phys_fd(int fd, void* ptr) {
+    uint64_t va = (uintptr_t)ptr;
+    uint64_t pagemap;
+    uint64_t offset;
+    uint64_t vfn;
+    uint64_t pa;
+    int pagesize;
+    ssize_t r;
+
+    pagesize = getpagesize();
+    offset = va % pagesize;
+    vfn = va / pagesize;
+    r = pread(fd, &pagemap, sizeof pagemap, 8 * vfn);
+    assert(r == sizeof pagemap);
+
+    if (!(pagemap & PAGEMAP_PAGE_PRESENT)) {
+        return PAGEMAP_FAILED;
+    }
+
+    pa = (pagemap & PAGEMAP_PFN_MASK) * pagesize;
+    if (!pa) {
+        return PAGEMAP_FAILED;
+    }
+
+    pa |= offset;
+    return pa;
+}
+
+// Translate a given virtual ptr into its physical address.
+static inline uint64_t pagemap_virt_to_phys(void* ptr) {
+    uint64_t pa;
+    int fd;
+
+    fd = pagemap_open_self();
+    if (fd < 0) {
+        return PAGEMAP_FAILED;
+    }
+
+    pa = pagemap_virt_to_phys_fd(fd, ptr);
+    close(fd);
+    return pa;
+}
+#endif
diff --git a/include/hw/virtio/spsc_queue.h b/include/hw/virtio/spsc_queue.h
new file mode 100644
index 0000000000..da572d1da1
--- /dev/null
+++ b/include/hw/virtio/spsc_queue.h
@@ -0,0 +1,267 @@
+// Single Producer Single Consumer Queue implemented over shared-memory
+
+// Copyright (c) 2023 Zero ASIC Corporation
+// This code is licensed under Apache License 2.0 (see LICENSE for details)
+
+#ifndef SPSC_QUEUE_H__
+#define SPSC_QUEUE_H__
+
+#include <assert.h>
+#include <fcntl.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#ifdef __cplusplus
+#include <atomic>
+using namespace std;
+#else
+#include <stdatomic.h>
+#endif
+
+#ifndef MAP_POPULATE
+// If the implementation lacks MAP_POPULATE, define it to 0 (no-op).
+#define MAP_POPULATE 0
+#endif
+
+#define SPSC_QUEUE_MAX_PACKET_SIZE 64
+#define SPSC_QUEUE_CACHE_LINE_SIZE 64
+
+typedef struct spsc_queue_shared {
+    int32_t head __attribute__((__aligned__(SPSC_QUEUE_CACHE_LINE_SIZE)));
+    int32_t tail __attribute__((__aligned__(SPSC_QUEUE_CACHE_LINE_SIZE)));
+    uint32_t packets[1][SPSC_QUEUE_MAX_PACKET_SIZE / 4]
+        __attribute__((__aligned__(SPSC_QUEUE_CACHE_LINE_SIZE)));
+} spsc_queue_shared;
+
+typedef struct spsc_queue {
+    int32_t cached_tail __attribute__((__aligned__(SPSC_QUEUE_CACHE_LINE_SIZE)));
+    int32_t cached_head __attribute__((__aligned__(SPSC_QUEUE_CACHE_LINE_SIZE)));
+    spsc_queue_shared* shm;
+    char* name;
+    int capacity;
+
+    bool unmap_at_close;
+} spsc_queue;
+
+// Returns the capacity of a queue given a specific mapsize.
+static inline int spsc_capacity(size_t mapsize) {
+    spsc_queue* q = NULL;
+    int capacity;
+
+    if (mapsize < sizeof(*q->shm)) {
+        return 0;
+    }
+
+    // Start with the size of the shared area. This includes the
+    // control members + one packet.
+    mapsize -= sizeof(*q->shm);
+
+    capacity = mapsize / sizeof(q->shm->packets[0]) + 1;
+
+    if (capacity < 2) {
+        // Capacities less than 2 are invalid.
+        return 0;
+    }
+
+    return capacity;
+}
+
+static inline size_t spsc_mapsize(int capacity) {
+    spsc_queue* q = NULL;
+    size_t mapsize;
+
+    assert(capacity >= 2);
+
+    // Start with the size of the shared area. This includes the
+    // control members + one packet.
+    mapsize = sizeof(*q->shm);
+    // Add additional packets.
+    mapsize += sizeof(q->shm->packets[0]) * (capacity - 1);
+
+    return mapsize;
+}
+
+static inline spsc_queue* spsc_open_mem(const char* name, size_t capacity, void* mem) {
+    spsc_queue* q = NULL;
+    size_t mapsize;
+    void* p;
+    int fd = -1;
+    int r;
+
+    // Compute the size of the SHM mapping.
+    mapsize = spsc_mapsize(capacity);
+
+    // Allocate a cache-line aligned spsc-queue.
+    r = posix_memalign(&p, SPSC_QUEUE_CACHE_LINE_SIZE, sizeof(spsc_queue));
+    if (r) {
+        fprintf(stderr, "posix_memalign: %s\n", strerror(r));
+        goto err;
+    }
+    q = (spsc_queue*)p;
+    memset(q, 0, sizeof *q);
+
+    p = mem;
+    if (!mem) {
+        fd = open(name, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
+        if (fd < 0) {
+            perror(name);
+            goto err;
+        }
+
+        r = ftruncate(fd, mapsize);
+        if (r < 0) {
+            perror("ftruncate");
+            goto err;
+        }
+
+        // Map a shared file-backed mapping for the SHM area.
+        // This will always be page-aligned.
+        p = mmap(NULL, mapsize, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE, fd, 0);
+
+        if (p == MAP_FAILED) {
+            perror("mmap");
+            goto err;
+        }
+
+        // We can now close the fd without affecting active mmaps.
+        close(fd);
+        q->unmap_at_close = true;
+    }
+
+    q->shm = (spsc_queue_shared*)p;
+    q->name = strdup(name);
+    q->capacity = capacity;
+
+    /* In case we're opening a pre-existing queue, pick up where we left off. */
+    __atomic_load(&q->shm->tail, &q->cached_tail, __ATOMIC_RELAXED);
+    __atomic_load(&q->shm->head, &q->cached_head, __ATOMIC_RELAXED);
+    return q;
+
+err:
+    if (fd > 0) {
+        close(fd);
+    }
+    free(q);
+    return NULL;
+}
+
+static inline int spsc_mlock(spsc_queue* q) {
+    size_t mapsize = spsc_mapsize(q->capacity);
+
+    return mlock(q->shm, mapsize);
+}
+
+static inline spsc_queue* spsc_open(const char* name, size_t capacity) {
+    return spsc_open_mem(name, capacity, NULL);
+}
+
+static inline void spsc_remove_shmfile(const char* name) {
+    remove(name);
+}
+
+static inline void spsc_close(spsc_queue* q) {
+    size_t mapsize;
+
+    if (!q) {
+        return;
+    }
+
+    mapsize = spsc_mapsize(q->capacity);
+
+    // We've already closed the file-descriptor. We now need to munmap the mmap.
+    if (q->unmap_at_close) {
+        munmap(q->shm, mapsize);
+    }
+
+    free(q->name);
+    free(q);
+}
+
+static inline int spsc_size(spsc_queue* q) {
+    int head, tail;
+    int size;
+
+    __atomic_load(&q->shm->head, &head, __ATOMIC_ACQUIRE);
+    __atomic_load(&q->shm->tail, &tail, __ATOMIC_ACQUIRE);
+
+    size = head - tail;
+    if (size < 0) {
+        size += q->capacity;
+    }
+    return size;
+}
+
+static inline bool spsc_send(spsc_queue* q, void* buf, size_t size) {
+    // get pointer to head
+    int head;
+
+    __atomic_load(&q->shm->head, &head, __ATOMIC_RELAXED);
+
+    assert(size <= sizeof q->shm->packets[0]);
+
+    // compute the head pointer
+    int next_head = head + 1;
+    if (next_head == q->capacity) {
+        next_head = 0;
+    }
+
+    // if the queue is full, bail out
+    if (next_head == q->cached_tail) {
+        __atomic_load(&q->shm->tail, &q->cached_tail, __ATOMIC_ACQUIRE);
+        if (next_head == q->cached_tail) {
+            return false;
+        }
+    }
+
+    // otherwise write in the packet
+    memcpy(q->shm->packets[head], buf, size);
+
+    // and update the head pointer
+    __atomic_store(&q->shm->head, &next_head, __ATOMIC_RELEASE);
+
+    return true;
+}
+
+static inline bool spsc_recv_base(spsc_queue* q, void* buf, size_t size, bool pop) {
+    // get the read pointer
+    int tail;
+    __atomic_load(&q->shm->tail, &tail, __ATOMIC_RELAXED);
+
+    assert(size <= sizeof q->shm->packets[0]);
+
+    // if the queue is empty, bail out
+    if (tail == q->cached_head) {
+        __atomic_load(&q->shm->head, &q->cached_head, __ATOMIC_ACQUIRE);
+        if (tail == q->cached_head) {
+            return false;
+        }
+    }
+
+    // otherwise read out the packet
+    memcpy(buf, q->shm->packets[tail], size);
+
+    if (pop) {
+        // and update the read pointer
+        tail++;
+        if (tail == q->capacity) {
+            tail = 0;
+        }
+        __atomic_store(&q->shm->tail, &tail, __ATOMIC_RELEASE);
+    }
+
+    return true;
+}
+
+static inline bool spsc_recv(spsc_queue* q, void* buf, size_t size) {
+    return spsc_recv_base(q, buf, size, true);
+}
+
+static inline bool spsc_recv_peek(spsc_queue* q, void* buf, size_t size) {
+    return spsc_recv_base(q, buf, size, false);
+}
+#endif // _SPSC_QUEUE
diff --git a/include/hw/virtio/virtio-bus.h b/include/hw/virtio/virtio-bus.h
index 7ab8c9dab0..043dbeb4cf 100644
--- a/include/hw/virtio/virtio-bus.h
+++ b/include/hw/virtio/virtio-bus.h
@@ -39,6 +39,7 @@ DECLARE_OBJ_CHECKERS(VirtioBusState, VirtioBusClass,
 struct VirtioBusClass {
     /* This is what a VirtioBus must implement */
     BusClass parent;
+    void (*notify_queue)(DeviceState *d, uint16_t index);
     void (*notify)(DeviceState *d, uint16_t vector);
     void (*save_config)(DeviceState *d, QEMUFile *f);
     void (*save_queue)(DeviceState *d, int n, QEMUFile *f);
diff --git a/include/hw/virtio/virtio-msg-bus-ivshmem.h b/include/hw/virtio/virtio-msg-bus-ivshmem.h
new file mode 100644
index 0000000000..c0aca224cb
--- /dev/null
+++ b/include/hw/virtio/virtio-msg-bus-ivshmem.h
@@ -0,0 +1,63 @@
+/*
+ * VirtIO MSG bus over IVSHMEM.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef QEMU_VIRTIO_MSG_BUS_IVSHMEM_H
+#define QEMU_VIRTIO_MSG_BUS_IVSHMEM_H
+
+#include "qom/object.h"
+#include "qemu/vfio-helpers.h"
+#include "sysemu/hostmem.h"
+#include "hw/virtio/virtio-msg-bus.h"
+#include "hw/virtio/spsc_queue.h"
+
+#define TYPE_VIRTIO_MSG_BUS_IVSHMEM "virtio-msg-bus-ivshmem"
+OBJECT_DECLARE_SIMPLE_TYPE(VirtIOMSGBusIVSHMEM, VIRTIO_MSG_BUS_IVSHMEM)
+#define VIRTIO_MSG_BUS_IVSHMEM_GET_PARENT_CLASS(obj) \
+        OBJECT_GET_PARENT_CLASS(obj, TYPE_VIRTIO_MSG_BUS_IVSHMEM)
+
+typedef struct VirtIOMSGBusIVSHMEM {
+    VirtIOMSGBusDevice parent;
+
+    AddressSpace as;
+    MemoryRegion mr;
+    MemoryRegion mr_lowmem;
+    MemoryRegion mr_highmem;
+    MemoryRegion *mr_memdev;
+
+    EventNotifier notifier;
+
+    struct {
+        spsc_queue *driver;
+        spsc_queue *device;
+    } shm_queues;
+
+    struct {
+        QEMUVFIOState *dev;
+
+        /* Memmap.  */
+        uint8_t *doorbell;
+        void *driver;
+        void *device;
+    } msg;
+
+    struct {
+        char *dev;
+        uint32_t remote_vmid;
+        bool reset_queues;
+
+        HostMemoryBackend *memdev;
+        /* FIXME: Need a better way  */
+        uint64_t mem_offset;
+        uint64_t mem_low_size;
+        uint64_t mem_hole;
+        char *iommu;
+    } cfg;
+} VirtIOMSGBusIVSHMEM;
+
+#endif
diff --git a/include/hw/virtio/virtio-msg-bus-linux-user.h b/include/hw/virtio/virtio-msg-bus-linux-user.h
new file mode 100644
index 0000000000..fac7f34889
--- /dev/null
+++ b/include/hw/virtio/virtio-msg-bus-linux-user.h
@@ -0,0 +1,56 @@
+/*
+ * VirtIO MSG bus between user-space proccesses on the same Linux host.
+ * A QEMU Chardev (preferably UNIX sockets) is used for notifications
+ * and an SPSC shared memory queue is used to move virtio-msg messages.
+ *
+ * The SPSC was borrowed from switchboard:
+ * https://github.com/zeroasiccorp/switchboard/
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef QEMU_VIRTIO_MSG_BUS_LINUX_USER_H
+#define QEMU_VIRTIO_MSG_BUS_LINUX_USER_H
+
+#include "qom/object.h"
+#include "chardev/char.h"
+#include "chardev/char-fe.h"
+#include "sysemu/hostmem.h"
+#include "hw/virtio/virtio-msg-bus.h"
+#include "hw/virtio/spsc_queue.h"
+
+#define TYPE_VIRTIO_MSG_BUS_LINUX_USER "virtio-msg-bus-linux-user"
+OBJECT_DECLARE_SIMPLE_TYPE(VirtIOMSGBusLinuxUser, VIRTIO_MSG_BUS_LINUX_USER)
+#define VIRTIO_MSG_BUS_LINUX_USER_GET_PARENT_CLASS(obj) \
+        OBJECT_GET_PARENT_CLASS(obj, TYPE_VIRTIO_MSG_BUS_LINUX_USER)
+
+typedef struct VirtIOMSGBusLinuxUser {
+    VirtIOMSGBusDevice parent;
+
+    AddressSpace as;
+    MemoryRegion mr;
+    MemoryRegion mr_lowmem;
+    MemoryRegion mr_highmem;
+    MemoryRegion *mr_memdev;
+
+    struct {
+        spsc_queue *driver;
+        spsc_queue *device;
+    } shm_queues;
+
+    struct {
+        char *name;
+        CharBackend chr;
+        HostMemoryBackend *memdev;
+
+        /* FIXME: Need a better way  */
+        uint64_t mem_offset;
+        uint64_t mem_low_size;
+        uint64_t mem_hole;
+    } cfg;
+} VirtIOMSGBusLinuxUser;
+
+#endif
diff --git a/include/hw/virtio/virtio-msg-bus-sapphire.h b/include/hw/virtio/virtio-msg-bus-sapphire.h
new file mode 100644
index 0000000000..2a4adcbd08
--- /dev/null
+++ b/include/hw/virtio/virtio-msg-bus-sapphire.h
@@ -0,0 +1,55 @@
+/*
+ * VirtIO MSG bus for sapphire with VEK280.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef QEMU_VIRTIO_MSG_BUS_SAPPHIRE_H
+#define QEMU_VIRTIO_MSG_BUS_SAPHHIRE_H
+
+#include "qom/object.h"
+#include "qemu/vfio-helpers.h"
+#include "hw/virtio/virtio-msg-bus.h"
+#include "hw/virtio/spsc_queue.h"
+
+#define TYPE_VIRTIO_MSG_BUS_SAPPHIRE "virtio-msg-bus-sapphire"
+OBJECT_DECLARE_SIMPLE_TYPE(VirtIOMSGBusSapphire, VIRTIO_MSG_BUS_SAPPHIRE)
+#define VIRTIO_MSG_BUS_SAPPHIRE_GET_PARENT_CLASS(obj) \
+        OBJECT_GET_PARENT_CLASS(obj, TYPE_VIRTIO_MSG_BUS_SAPPHIRE)
+
+typedef struct VirtIOMSGBusSapphire {
+    VirtIOMSGBusDevice parent;
+
+    EventNotifier notifier;
+    QEMUTimer timer;
+
+    struct {
+        MemoryRegion mr;
+        spsc_queue *driver;
+        spsc_queue *device;
+        bool flowing;
+    } shm_queues;
+
+    struct {
+        QEMUVFIOState *dev;
+
+        /* Memmap.  */
+        uint8_t *doorbell;
+        uint32_t *cfg_bram;
+        void *driver;
+        void *device;
+        void *ram;
+    } msg;
+
+    struct {
+        char *dev;
+        bool reset_queues;
+
+        char *iommu;
+    } cfg;
+} VirtIOMSGBusSapphire;
+
+#endif
diff --git a/include/hw/virtio/virtio-msg-bus-vek280-hexcam.h b/include/hw/virtio/virtio-msg-bus-vek280-hexcam.h
new file mode 100644
index 0000000000..55ccd7d686
--- /dev/null
+++ b/include/hw/virtio/virtio-msg-bus-vek280-hexcam.h
@@ -0,0 +1,64 @@
+/*
+ * VirtIO MSG bus for the VEK280 hexcam design.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef QEMU_VIRTIO_MSG_BUS_VEK280_HEXCAM_H
+#define QEMU_VIRTIO_MSG_BUS_VEK280_HEXCAM_H
+
+#include "qom/object.h"
+#include "qemu/vfio-helpers.h"
+#include "sysemu/hostmem.h"
+#include "hw/virtio/virtio-msg-bus.h"
+#include "hw/virtio/spsc_queue.h"
+
+#define TYPE_VIRTIO_MSG_BUS_VEK280_HEXCAM "virtio-msg-bus-vek280-hexcam"
+OBJECT_DECLARE_SIMPLE_TYPE(VirtIOMSGBusVEK280HexCam,
+                           VIRTIO_MSG_BUS_VEK280_HEXCAM)
+#define VIRTIO_MSG_BUS_VEK280_HEXCAM_GET_PARENT_CLASS(obj) \
+        OBJECT_GET_PARENT_CLASS(obj, TYPE_VIRTIO_MSG_BUS_VEK280_HEXCAM)
+
+typedef struct VirtIOMSGBusVEK280HexCam {
+    VirtIOMSGBusDevice parent;
+
+    AddressSpace as;
+    MemoryRegion mr;
+    MemoryRegion mr_host;
+    MemoryRegion mr_host_ram;
+    MemoryRegion mr_host_ram_alias;
+
+    EventNotifier notifier;
+
+    struct {
+        spsc_queue *driver;
+        spsc_queue *device;
+    } shm_queues;
+
+    struct {
+        int fd;
+        int fd_devmem;
+
+        /* Memmap.  */
+        uint32_t *doorbell;
+        uint32_t *cfg_bram;
+        void *driver;
+        void *device;
+        void *host;
+    } msg;
+
+    struct {
+        char *dev;
+        bool reset_queues;
+        uint64_t spsc_base;
+        uint64_t mem_offset;
+        uint64_t mem_size;
+
+        char *iommu;
+    } cfg;
+} VirtIOMSGBusVEK280HexCam;
+
+#endif
diff --git a/include/hw/virtio/virtio-msg-bus-xen.h b/include/hw/virtio/virtio-msg-bus-xen.h
new file mode 100644
index 0000000000..f44efa6ecb
--- /dev/null
+++ b/include/hw/virtio/virtio-msg-bus-xen.h
@@ -0,0 +1,46 @@
+/*
+ * VirtIO MSG bus on top of Xen. 
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef QEMU_VIRTIO_MSG_BUS_XEN_H
+#define QEMU_VIRTIO_MSG_BUS_XEN_H
+
+#include "qom/object.h"
+#include "chardev/char.h"
+#include "chardev/char-fe.h"
+#include "sysemu/hostmem.h"
+#include "hw/virtio/virtio-msg-bus.h"
+#include "hw/virtio/spsc_queue.h"
+
+#define TYPE_VIRTIO_MSG_BUS_XEN "virtio-msg-bus-xen"
+OBJECT_DECLARE_SIMPLE_TYPE(VirtIOMSGBusXen, VIRTIO_MSG_BUS_XEN)
+#define VIRTIO_MSG_BUS_XEN_GET_PARENT_CLASS(obj) \
+        OBJECT_GET_PARENT_CLASS(obj, TYPE_VIRTIO_MSG_BUS_XEN)
+
+typedef struct VirtIOMSGBusXen {
+    VirtIOMSGBusDevice parent;
+
+    struct {
+        xenevtchn_handle *eh;
+
+        char *shm;
+        evtchn_port_t local_port;
+    } xen;
+
+    struct {
+        spsc_queue *driver;
+        spsc_queue *device;
+    } shm_queues;
+
+    struct {
+        uint64_t shm_base;
+        uint64_t shm_gnt_ref;
+        uint16_t port;
+    } cfg;
+} VirtIOMSGBusXen;
+#endif
diff --git a/include/hw/virtio/virtio-msg-bus.h b/include/hw/virtio/virtio-msg-bus.h
new file mode 100644
index 0000000000..7ed01f8430
--- /dev/null
+++ b/include/hw/virtio/virtio-msg-bus.h
@@ -0,0 +1,153 @@
+/*
+ * VirtIO MSG bus.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef QEMU_VIRTIO_MSG_BUS_H
+#define QEMU_VIRTIO_MSG_BUS_H
+
+#include "qom/object.h"
+#include "sysemu/dma.h"
+#include "hw/qdev-core.h"
+#include "hw/virtio/virtio-msg-prot.h"
+
+#define TYPE_VIRTIO_MSG_BUS "virtio-msg-bus"
+DECLARE_INSTANCE_CHECKER(BusState, VIRTIO_MSG_BUS,
+                         TYPE_VIRTIO_MSG_BUS)
+
+
+#define TYPE_VIRTIO_MSG_BUS_DEVICE "virtio-msg-bus-device"
+OBJECT_DECLARE_TYPE(VirtIOMSGBusDevice, VirtIOMSGBusDeviceClass,
+                    VIRTIO_MSG_BUS_DEVICE)
+
+typedef struct VirtIOMSGBusPort {
+    int (*receive)(VirtIOMSGBusDevice *bus, VirtIOMSG *msg);
+    bool is_driver;
+} VirtIOMSGBusPort;
+
+struct VirtIOMSGBusDeviceClass {
+    /*< private >*/
+    DeviceClass parent_class;
+
+    DeviceRealize parent_realize;
+
+    /*
+     * Ask the bus to receive and process all messages that
+     * are readily available. The bus will call the registered
+     * VirtIOMSGBusPort.receive() function for each message.
+     *
+     * Will return immediately if no messages are available.
+     */
+    void (*process)(VirtIOMSGBusDevice *bd);
+
+    /*
+     * Called by the transport to send a message and optionally
+     * wait for a response.
+     */
+    int (*send)(VirtIOMSGBusDevice *bd, VirtIOMSG *msg_req,
+                VirtIOMSG *msg_resp);
+
+    /*
+     * A bus device can construct a view into the guests address-space.
+     */
+    AddressSpace *(*get_remote_as)(VirtIOMSGBusDevice *bd);
+};
+
+typedef struct VirtIOMSGBusDevice {
+    DeviceState parent;
+
+    IOMMUTLBEntry (*iommu_translate)(VirtIOMSGBusDevice *bd,
+                                     uint64_t va, uint8_t prot);
+
+    /* Out of order queue.  */
+    struct {
+        VirtIOMSG msg[128];
+        int num;
+        int pos;
+    } ooo_queue;
+
+    /* SW IOMMUs.  */
+    int pagemap_fd;
+    int virt2gfn_fd;
+
+    const VirtIOMSGBusPort *peer;
+    void *opaque;
+} VirtIOMSGBusDevice;
+
+static inline VirtIOMSGBusDevice *virtio_msg_bus_get_device(BusState *qbus)
+{
+    BusChild *kid = QTAILQ_FIRST(&qbus->children);
+    DeviceState *qdev = kid ? kid->child : NULL;
+
+    return (VirtIOMSGBusDevice *)qdev;
+}
+
+static inline bool virtio_msg_bus_connected(BusState *bus)
+{
+    VirtIOMSGBusDevice *bd = virtio_msg_bus_get_device(bus);
+
+    return bd && bd->peer != NULL;
+}
+
+void virtio_msg_bus_ooo_receive(VirtIOMSGBusDevice *bd,
+                                VirtIOMSG *msg_req,
+                                VirtIOMSG *msg_resp);
+void virtio_msg_bus_ooo_process(VirtIOMSGBusDevice *bd);
+void virtio_msg_bus_process(VirtIOMSGBusDevice *bd);
+
+bool virtio_msg_bus_connect(BusState *bus,
+                            const VirtIOMSGBusPort *port,
+                            void *opaque);
+
+static inline void
+virtio_msg_bus_receive(VirtIOMSGBusDevice *bd, VirtIOMSG *msg)
+{
+    virtio_msg_unpack(msg);
+    bd->peer->receive(bd, msg);
+}
+
+int virtio_msg_bus_send(BusState *bus,
+                        VirtIOMSG *msg_req, VirtIOMSG *msg_resp);
+
+static inline AddressSpace *virtio_msg_bus_get_remote_as(BusState *bus)
+{
+    VirtIOMSGBusDeviceClass *bdc;
+
+    VirtIOMSGBusDevice *bd = virtio_msg_bus_get_device(bus);
+    bdc = VIRTIO_MSG_BUS_DEVICE_CLASS(object_get_class(OBJECT(bd)));
+
+    if (bdc->get_remote_as) {
+        return bdc->get_remote_as(bd);
+    }
+    return NULL;
+}
+
+IOMMUTLBEntry virtio_msg_bus_xen_gfn2mfn_translate(VirtIOMSGBusDevice *bd,
+                                                   uint64_t va,
+                                                   uint8_t prot);
+
+IOMMUTLBEntry virtio_msg_bus_xen_virt2gfn_translate(VirtIOMSGBusDevice *bd,
+                                                    uint64_t va,
+                                                    uint8_t prot);
+
+IOMMUTLBEntry virtio_msg_bus_pagemap_translate(VirtIOMSGBusDevice *bd,
+                                               uint64_t va,
+                                               uint8_t prot);
+
+static inline IOMMUTLBEntry
+virtio_msg_bus_iommu_translate(BusState *bus,
+                               uint64_t va, uint8_t prot)
+{
+    VirtIOMSGBusDevice *bd = virtio_msg_bus_get_device(bus);
+    IOMMUTLBEntry dummy = {0};
+
+    if (bd->iommu_translate) {
+        return bd->iommu_translate(bd, va, prot);
+    }
+    return dummy;
+}
+#endif
diff --git a/include/hw/virtio/virtio-msg-machine.h b/include/hw/virtio/virtio-msg-machine.h
new file mode 100644
index 0000000000..ee296e97e1
--- /dev/null
+++ b/include/hw/virtio/virtio-msg-machine.h
@@ -0,0 +1,16 @@
+#ifndef HW_VIRTIO_VIRTIO_MSG_MACHINE_H
+#define HW_VIRTIO_VIRTIO_MSG_MACHINE_H
+
+#include "qom/object.h"
+#include "hw/boards.h"
+#include "hw/virtio/virtio-msg.h"
+
+struct VirtIOMSGMachineState {
+    MachineState parent_obj;
+
+    VirtIOMSGProxy backends[4];
+};
+
+#define TYPE_VIRTIO_MSG_MACHINE "x-virtio-msg-machine"
+OBJECT_DECLARE_SIMPLE_TYPE(VirtIOMSGMachineState, VIRTIO_MSG_MACHINE)
+#endif
diff --git a/include/hw/virtio/virtio-msg-prot.h b/include/hw/virtio/virtio-msg-prot.h
new file mode 100644
index 0000000000..cd9d706d89
--- /dev/null
+++ b/include/hw/virtio/virtio-msg-prot.h
@@ -0,0 +1,686 @@
+/*
+ * Virtio MSG - Message packing/unpacking functions.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>.
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef QEMU_VIRTIO_MSG_H
+#define QEMU_VIRTIO_MSG_H
+
+#ifdef __XEN__
+/* Xen compat */
+#include <xen/lib.h>
+#include <xen/ctype.h>
+#include <xen/stringify.h>
+#include <xen/bug.h>
+#include <xen/virtio_config.h>
+#include <asm/byteorder.h>
+#define assert ASSERT
+#define QEMU_PACKED __packed
+#define g_assert_not_reached ASSERT_UNREACHABLE
+#define stringify __stringify
+#define printf printk
+#else
+#include <stdint.h>
+#include "standard-headers/linux/virtio_config.h"
+#endif
+
+/* v0.0.1.  */
+#define VIRTIO_MSG_DEVICE_VERSION 0x000001
+#define VIRTIO_MSG_VENDOR_ID 0x554D4551 /* 'QEMU' */
+
+enum {
+    VIRTIO_MSG_NO_ERROR = 0,
+    VIRTIO_MSG_ERROR_UNSUPPORTED_MESSAGE_ID = 1,
+};
+
+enum {
+    VIRTIO_MSG_CONNECT           = 0x01,
+    VIRTIO_MSG_DISCONNECT        = 0x02,
+    VIRTIO_MSG_DEVICE_INFO       = 0x03,
+    VIRTIO_MSG_GET_FEATURES      = 0x04,
+    VIRTIO_MSG_SET_FEATURES      = 0x05,
+    VIRTIO_MSG_GET_CONFIG        = 0x06,
+    VIRTIO_MSG_SET_CONFIG        = 0x07,
+    VIRTIO_MSG_GET_CONFIG_GEN    = 0x08,
+    VIRTIO_MSG_GET_DEVICE_STATUS = 0x09,
+    VIRTIO_MSG_SET_DEVICE_STATUS = 0x0a,
+    VIRTIO_MSG_GET_VQUEUE        = 0x0b,
+    VIRTIO_MSG_SET_VQUEUE        = 0x0c,
+    VIRTIO_MSG_RESET_VQUEUE      = 0x0d,
+    VIRTIO_MSG_EVENT_CONFIG      = 0x10,
+    VIRTIO_MSG_EVENT_AVAIL       = 0x11,
+    VIRTIO_MSG_EVENT_USED        = 0x12,
+
+    /* Experimental. For setups without IOMMU's, e.g ivshmem */
+    VIRTIO_MSG_IOMMU_ENABLE      = 0x20,
+    VIRTIO_MSG_IOMMU_TRANSLATE   = 0x21,
+    VIRTIO_MSG_IOMMU_INVALIDATE  = 0x22,
+
+    VIRTIO_MSG_MAX = VIRTIO_MSG_IOMMU_INVALIDATE,
+};
+
+#define VIRTIO_MSG_MAX_SIZE 40
+
+#define VIRTIO_MSG_TYPE_RESPONSE  (1 << 0)
+#define VIRTIO_MSG_TYPE_BUS       (1 << 1)
+
+typedef struct VirtIOMSG {
+    uint8_t type;
+    uint8_t id;
+    uint16_t dev_id;
+
+    union {
+        uint8_t payload_u8[36];
+
+        struct {
+            uint32_t device_version;
+            uint32_t device_id;
+            uint32_t vendor_id;
+        } QEMU_PACKED get_device_info_resp;
+        struct {
+            uint32_t index;
+        } QEMU_PACKED get_features;
+        struct {
+            uint32_t index;
+            uint64_t features;
+        } QEMU_PACKED get_features_resp;
+        struct {
+            uint32_t index;
+            uint64_t features;
+        } QEMU_PACKED set_features;
+        struct {
+            uint32_t index;
+            uint64_t features;
+        } QEMU_PACKED set_features_resp;
+        struct {
+            uint32_t status;
+        } QEMU_PACKED get_device_status_resp;
+        struct {
+            uint32_t status;
+        } QEMU_PACKED set_device_status;
+        struct {
+            uint16_t offset;
+            uint8_t offset_msb;
+            uint8_t size;
+        } QEMU_PACKED get_config;
+        struct {
+            uint16_t offset;
+            uint8_t offset_msb;
+            uint8_t size;
+            uint64_t data;
+        } QEMU_PACKED get_config_resp;
+        struct {
+            uint16_t offset;
+            uint8_t offset_msb;
+            uint8_t size;
+            uint64_t data;
+        } QEMU_PACKED set_config;
+        struct {
+            uint16_t offset;
+            uint8_t offset_msb;
+            uint8_t size;
+            uint64_t data;
+        } QEMU_PACKED set_config_resp;
+        struct {
+            uint32_t generation;
+        } QEMU_PACKED get_config_gen_resp;
+        struct {
+            uint32_t index;
+        } QEMU_PACKED get_vqueue;
+        struct {
+            uint32_t index;
+            uint32_t max_size;
+        } QEMU_PACKED get_vqueue_resp;
+        struct {
+            uint32_t index;
+            uint32_t size;
+            uint64_t descriptor_addr;
+            uint64_t driver_addr;
+            uint64_t device_addr;
+        } QEMU_PACKED set_vqueue;
+        struct {
+            uint32_t status;
+            uint16_t config_offset;
+            uint8_t config_offset_msb;
+            uint8_t config_size;
+            uint8_t config_value[16];
+        } QEMU_PACKED event_config;
+        struct {
+            uint32_t index;
+            uint64_t next_offset;
+            uint64_t next_wrap;
+        } QEMU_PACKED event_avail;
+        struct {
+            uint32_t index;
+        } QEMU_PACKED event_used;
+
+
+        /* Experimental Soft IOMMU.  */
+        struct {
+            uint8_t enable;
+        } QEMU_PACKED iommu_enable;
+
+        struct {
+#define VIRTIO_MSG_IOMMU_PAGE_SIZE (4 * 1024)
+#define VIRTIO_MSG_IOMMU_PAGE_MASK (VIRTIO_MSG_IOMMU_PAGE_SIZE - 1)
+            uint64_t va;
+#define VIRTIO_MSG_IOMMU_PROT_READ  (1U << 0)
+#define VIRTIO_MSG_IOMMU_PROT_WRITE (1U << 1)
+            uint8_t prot;
+        } QEMU_PACKED iommu_translate;
+        struct {
+            uint64_t va;
+            uint64_t pa;
+            uint8_t prot;
+        } QEMU_PACKED iommu_translate_resp;
+    };
+} QEMU_PACKED VirtIOMSG;
+
+#define LE_TO_CPU(v)                                        \
+{                                                           \
+    if (sizeof(v) == 2) {                                   \
+        v = le16_to_cpu(v);                                 \
+    } else if (sizeof(v) == 4) {                            \
+        v = le32_to_cpu(v);                                 \
+    } else if (sizeof(v) == 8) {                            \
+        v = le64_to_cpu(v);                                 \
+    } else {                                                \
+        g_assert_not_reached();                             \
+    }                                                       \
+}
+
+/**
+ * virtio_msg_unpack_resp: Unpacks a wire virtio message responses into
+ *                         a host version
+ * @msg: the virtio message to unpack
+ *
+ * See virtio_msg_unpack().
+ */
+static inline void virtio_msg_unpack_resp(VirtIOMSG *msg)
+{
+    LE_TO_CPU(msg->dev_id);
+
+    switch (msg->id) {
+    case VIRTIO_MSG_DEVICE_INFO:
+        LE_TO_CPU(msg->get_device_info_resp.device_version);
+        LE_TO_CPU(msg->get_device_info_resp.device_id);
+        LE_TO_CPU(msg->get_device_info_resp.vendor_id);
+        break;
+    case VIRTIO_MSG_GET_FEATURES:
+        LE_TO_CPU(msg->get_features_resp.index);
+        LE_TO_CPU(msg->get_features_resp.features);
+        break;
+    case VIRTIO_MSG_GET_DEVICE_STATUS:
+        LE_TO_CPU(msg->get_device_status_resp.status);
+        break;
+    case VIRTIO_MSG_GET_CONFIG:
+        LE_TO_CPU(msg->get_config_resp.offset);
+        LE_TO_CPU(msg->get_config_resp.data);
+        break;
+    case VIRTIO_MSG_SET_CONFIG:
+        LE_TO_CPU(msg->set_config_resp.offset);
+        LE_TO_CPU(msg->set_config_resp.data);
+        break;
+    case VIRTIO_MSG_GET_CONFIG_GEN:
+        LE_TO_CPU(msg->get_config_gen_resp.generation);
+        break;
+    case VIRTIO_MSG_GET_VQUEUE:
+        LE_TO_CPU(msg->get_vqueue_resp.index);
+        LE_TO_CPU(msg->get_vqueue_resp.max_size);
+        break;
+    case VIRTIO_MSG_IOMMU_TRANSLATE:
+        LE_TO_CPU(msg->iommu_translate_resp.va);
+        LE_TO_CPU(msg->iommu_translate_resp.pa);
+        break;
+    default:
+        break;
+    }
+}
+
+/**
+ * virtio_msg_unpack: Unpacks a wire virtio message into a host version
+ * @msg: the virtio message to unpack
+ *
+ * Virtio messages arriving on the virtio message bus have a specific
+ * formate (little-endian, packet encoding, etc). To simplify for the
+ * the rest of the implementation, we have packers and unpackers that
+ * convert the wire messages into host versions. This includes endianess
+ * conversion and potentially future decoding and expansion.
+ *
+ * At the moment, we only do endian conversion, virtio_msg_unpack() should
+ * get completely eliminated by the compiler when targetting little-endian
+ * hosts.
+ */
+static inline void virtio_msg_unpack(VirtIOMSG *msg) {
+    if (msg->type & VIRTIO_MSG_TYPE_RESPONSE) {
+        virtio_msg_unpack_resp(msg);
+        return;
+    }
+
+    LE_TO_CPU(msg->dev_id);
+
+    switch (msg->id) {
+    case VIRTIO_MSG_GET_FEATURES:
+        LE_TO_CPU(msg->get_features.index);
+        break;
+    case VIRTIO_MSG_SET_FEATURES:
+        LE_TO_CPU(msg->set_features.index);
+        LE_TO_CPU(msg->set_features.features);
+        break;
+    case VIRTIO_MSG_SET_DEVICE_STATUS:
+        LE_TO_CPU(msg->set_device_status.status);
+        break;
+    case VIRTIO_MSG_GET_CONFIG:
+        LE_TO_CPU(msg->get_config.offset);
+        break;
+    case VIRTIO_MSG_SET_CONFIG:
+        LE_TO_CPU(msg->set_config.offset);
+        LE_TO_CPU(msg->set_config.data);
+        break;
+    case VIRTIO_MSG_GET_VQUEUE:
+        LE_TO_CPU(msg->get_vqueue.index);
+        break;
+    case VIRTIO_MSG_SET_VQUEUE:
+        LE_TO_CPU(msg->set_vqueue.index);
+        LE_TO_CPU(msg->set_vqueue.size);
+        LE_TO_CPU(msg->set_vqueue.descriptor_addr);
+        LE_TO_CPU(msg->set_vqueue.driver_addr);
+        LE_TO_CPU(msg->set_vqueue.device_addr);
+        break;
+    case VIRTIO_MSG_EVENT_CONFIG:
+        LE_TO_CPU(msg->event_config.status);
+        LE_TO_CPU(msg->event_config.config_offset);
+        break;
+    case VIRTIO_MSG_EVENT_AVAIL:
+        LE_TO_CPU(msg->event_avail.index);
+        LE_TO_CPU(msg->event_avail.next_offset);
+        LE_TO_CPU(msg->event_avail.next_wrap);
+        break;
+    case VIRTIO_MSG_EVENT_USED:
+        LE_TO_CPU(msg->event_used.index);
+        break;
+    case VIRTIO_MSG_IOMMU_TRANSLATE:
+        LE_TO_CPU(msg->iommu_translate.va);
+        break;
+    default:
+        break;
+    } 
+}
+
+static inline void virtio_msg_pack_header(VirtIOMSG *msg,
+                                          uint8_t id,
+                                          uint8_t type,
+                                          uint16_t dev_id)
+{
+    msg->type = type;
+    msg->id = id;
+    msg->dev_id = cpu_to_le16(dev_id); /* dest demux? */
+
+    /* Keep things predictable.  */
+    memset(msg->payload_u8, 0, sizeof msg->payload_u8);
+}
+
+static inline void virtio_msg_pack_get_device_info(VirtIOMSG *msg)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_DEVICE_INFO, 0, 0);
+}
+
+static inline void virtio_msg_pack_get_device_info_resp(VirtIOMSG *msg,
+                                                   uint32_t dev_version,
+                                                   uint32_t dev_id,
+                                                   uint32_t vendor_id)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_DEVICE_INFO,
+                           VIRTIO_MSG_TYPE_RESPONSE, 0);
+
+    msg->get_device_info_resp.device_version = cpu_to_le32(dev_version);
+    msg->get_device_info_resp.device_id = cpu_to_le32(dev_id);
+    msg->get_device_info_resp.vendor_id = cpu_to_le32(vendor_id);
+}
+
+static inline void virtio_msg_pack_get_features(VirtIOMSG *msg,
+                                                uint32_t index)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_GET_FEATURES, 0, 0);
+
+    msg->get_features.index = cpu_to_le32(index);
+}
+
+static inline void virtio_msg_pack_get_features_resp(VirtIOMSG *msg,
+                                                     uint32_t index,
+                                                     uint64_t f)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_GET_FEATURES,
+                           VIRTIO_MSG_TYPE_RESPONSE, 0);
+
+    msg->get_features_resp.index = cpu_to_le32(index);
+    msg->get_features_resp.features = cpu_to_le64(f);
+}
+
+static inline void virtio_msg_pack_set_features(VirtIOMSG *msg,
+                                                uint32_t index,
+                                                uint64_t f)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_SET_FEATURES, 0, 0);
+
+    msg->set_features.index = cpu_to_le32(index);
+    msg->set_features.features = cpu_to_le64(f);
+}
+
+static inline void virtio_msg_pack_set_features_resp(VirtIOMSG *msg,
+                                                     uint32_t index,
+                                                     uint64_t f)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_SET_FEATURES,
+                           VIRTIO_MSG_TYPE_RESPONSE, 0);
+
+    msg->set_features_resp.index = cpu_to_le32(index);
+    msg->set_features_resp.features = cpu_to_le64(f);
+}
+
+static inline void virtio_msg_pack_set_device_status(VirtIOMSG *msg,
+                                                     uint32_t status)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_SET_DEVICE_STATUS, 0, 0);
+
+    msg->set_device_status.status = cpu_to_le32(status);
+}
+
+static inline void virtio_msg_pack_get_device_status(VirtIOMSG *msg)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_GET_DEVICE_STATUS, 0, 0);
+}
+
+static inline void virtio_msg_pack_get_device_status_resp(VirtIOMSG *msg,
+                                                          uint32_t status)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_GET_DEVICE_STATUS,
+                           VIRTIO_MSG_TYPE_RESPONSE, 0);
+
+    msg->get_device_status_resp.status = cpu_to_le32(status);
+}
+
+static inline void virtio_msg_pack_get_config(VirtIOMSG *msg,
+                                              uint8_t size,
+                                              uint32_t offset)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_GET_CONFIG, 0, 0);
+
+    msg->get_config.offset = cpu_to_le16(offset);
+    msg->get_config.offset_msb = offset >> 16;
+    msg->get_config.size = size;
+}
+
+static inline void virtio_msg_pack_get_config_resp(VirtIOMSG *msg,
+                                                        uint8_t size,
+                                                        uint32_t offset,
+                                                        uint64_t data)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_GET_CONFIG,
+                           VIRTIO_MSG_TYPE_RESPONSE, 0);
+
+    msg->get_config_resp.offset = cpu_to_le16(offset);
+    msg->get_config_resp.offset_msb = offset >> 16;
+    msg->get_config_resp.size = size;
+    msg->get_config_resp.data = cpu_to_le64(data);
+}
+
+static inline void virtio_msg_pack_set_config(VirtIOMSG *msg,
+                                                   uint8_t size,
+                                                   uint32_t offset,
+                                                   uint64_t data)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_SET_CONFIG, 0, 0);
+
+    msg->set_config.offset = cpu_to_le16(offset);
+    msg->set_config.offset_msb = offset >> 16;
+    msg->set_config.size = size;
+    msg->set_config.data = cpu_to_le64(data);
+}
+
+static inline void virtio_msg_pack_set_config_resp(VirtIOMSG *msg,
+                                                   uint8_t size,
+                                                   uint32_t offset,
+                                                   uint64_t data)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_SET_CONFIG,
+                           VIRTIO_MSG_TYPE_RESPONSE, 0);
+
+    msg->set_config_resp.offset = cpu_to_le16(offset);
+    msg->set_config_resp.offset_msb = offset >> 16;
+    msg->set_config_resp.size = size;
+    msg->set_config_resp.data = cpu_to_le64(data);
+}
+
+static inline void virtio_msg_pack_get_config_gen(VirtIOMSG *msg)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_GET_CONFIG_GEN, 0, 0);
+}
+
+static inline void virtio_msg_pack_get_config_gen_resp(VirtIOMSG *msg,
+                                                       uint32_t gen)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_GET_CONFIG_GEN,
+                           VIRTIO_MSG_TYPE_RESPONSE, 0);
+
+    msg->get_config_gen_resp.generation = cpu_to_le32(gen);
+}
+
+static inline void virtio_msg_pack_get_vqueue(VirtIOMSG *msg,
+                                              uint32_t index)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_GET_VQUEUE, 0, 0);
+
+    msg->get_vqueue.index = cpu_to_le32(index);
+}
+
+static inline void virtio_msg_pack_get_vqueue_resp(VirtIOMSG *msg,
+                                                   uint32_t index,
+                                                   uint32_t max_size)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_GET_VQUEUE,
+                           VIRTIO_MSG_TYPE_RESPONSE, 0);
+
+    msg->get_vqueue_resp.index = cpu_to_le32(index);
+    msg->get_vqueue_resp.max_size = cpu_to_le32(max_size);
+}
+
+static inline void virtio_msg_pack_set_vqueue(VirtIOMSG *msg,
+                                              uint32_t index,
+                                              uint32_t size,
+                                              uint64_t descriptor_addr,
+                                              uint64_t driver_addr,
+                                              uint64_t device_addr)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_SET_VQUEUE, 0, 0);
+
+    msg->set_vqueue.index = cpu_to_le32(index);
+    msg->set_vqueue.size = cpu_to_le32(size);
+    msg->set_vqueue.descriptor_addr = cpu_to_le64(descriptor_addr);
+    msg->set_vqueue.driver_addr = cpu_to_le64(driver_addr);
+    msg->set_vqueue.device_addr = cpu_to_le64(device_addr);
+}
+
+static inline void virtio_msg_pack_event_avail(VirtIOMSG *msg,
+                                               uint32_t index,
+                                               uint64_t next_offset,
+                                               uint64_t next_wrap)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_EVENT_AVAIL, 0, 0);
+
+    msg->event_avail.index = cpu_to_le32(index);
+    msg->event_avail.next_offset = cpu_to_le64(next_offset);
+    msg->event_avail.next_wrap = cpu_to_le64(next_wrap);
+}
+
+static inline void virtio_msg_pack_event_used(VirtIOMSG *msg, uint32_t index)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_EVENT_USED, 0, 0);
+
+    msg->event_used.index = cpu_to_le32(index);
+}
+
+static inline void virtio_msg_pack_event_config(VirtIOMSG *msg,
+                                                uint32_t status,
+                                                uint32_t offset,
+                                                uint8_t size,
+                                                uint8_t *value)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_EVENT_CONFIG, 0, 0);
+
+    msg->event_config.status = cpu_to_le32(status);
+    msg->event_config.config_offset = cpu_to_le16(offset & 0xffff);
+    msg->event_config.config_offset_msb = offset >> 24;
+    msg->event_config.config_size = size;
+
+    if (size > 0) {
+        memcpy(&msg->event_config.config_value[0], value, size);
+    }
+}
+
+static inline void virtio_msg_pack_iommu_enable(VirtIOMSG *msg,
+                                                bool enable)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_IOMMU_ENABLE, 0, 0);
+
+    msg->iommu_enable.enable = enable;
+}
+
+static inline void virtio_msg_pack_iommu_translate(VirtIOMSG *msg,
+                                                   uint64_t va,
+                                                   uint8_t prot)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_IOMMU_TRANSLATE, 0, 0);
+
+    msg->iommu_translate.va = cpu_to_le64(va);
+    msg->iommu_translate.prot = prot;
+}
+
+static inline void virtio_msg_pack_iommu_translate_resp(VirtIOMSG *msg,
+                                                        uint64_t va,
+                                                        uint64_t pa,
+                                                        uint8_t prot)
+{
+    virtio_msg_pack_header(msg, VIRTIO_MSG_IOMMU_TRANSLATE,
+                           VIRTIO_MSG_TYPE_RESPONSE, 0);
+
+    msg->iommu_translate_resp.va = cpu_to_le64(va);
+    msg->iommu_translate_resp.pa = cpu_to_le64(pa);
+    msg->iommu_translate_resp.prot = prot;
+}
+
+/*
+ * Return true if msg_resp is a response for msg_req.
+ */
+static inline bool virtio_msg_is_resp(VirtIOMSG *msg_req, VirtIOMSG *msg_resp)
+{
+    if (msg_resp->id == msg_req->id &&
+        msg_resp->type & VIRTIO_MSG_TYPE_RESPONSE) {
+        return true;
+    }
+    return false;
+}
+
+static inline const char *virtio_msg_id_to_str(unsigned int type)
+{
+#define VIRTIO_MSG_TYPE2STR(x) [ VIRTIO_MSG_ ## x ] = stringify(x)
+    static const char *type2str[VIRTIO_MSG_MAX + 1] = {
+        VIRTIO_MSG_TYPE2STR(CONNECT),
+        VIRTIO_MSG_TYPE2STR(DISCONNECT),
+        VIRTIO_MSG_TYPE2STR(DEVICE_INFO),
+        VIRTIO_MSG_TYPE2STR(GET_FEATURES),
+        VIRTIO_MSG_TYPE2STR(SET_FEATURES),
+        VIRTIO_MSG_TYPE2STR(GET_CONFIG),
+        VIRTIO_MSG_TYPE2STR(SET_CONFIG),
+        VIRTIO_MSG_TYPE2STR(GET_CONFIG_GEN),
+        VIRTIO_MSG_TYPE2STR(GET_DEVICE_STATUS),
+        VIRTIO_MSG_TYPE2STR(SET_DEVICE_STATUS),
+        VIRTIO_MSG_TYPE2STR(GET_VQUEUE),
+        VIRTIO_MSG_TYPE2STR(SET_VQUEUE),
+        VIRTIO_MSG_TYPE2STR(RESET_VQUEUE),
+        VIRTIO_MSG_TYPE2STR(EVENT_CONFIG),
+        VIRTIO_MSG_TYPE2STR(EVENT_AVAIL),
+        VIRTIO_MSG_TYPE2STR(EVENT_USED),
+        VIRTIO_MSG_TYPE2STR(IOMMU_TRANSLATE),
+        VIRTIO_MSG_TYPE2STR(IOMMU_INVALIDATE),
+    };
+
+    return type2str[type];
+}
+
+static inline void virtio_msg_print_status(uint32_t status)
+{
+    printf("status %x", status);
+
+    if (status & VIRTIO_CONFIG_S_ACKNOWLEDGE) {
+        printf(" ACKNOWLEDGE");
+    }
+    if (status & VIRTIO_CONFIG_S_DRIVER) {
+        printf(" DRIVER");
+    }
+    if (status & VIRTIO_CONFIG_S_DRIVER_OK) {
+        printf(" DRIVER_OK");
+    }
+    if (status & VIRTIO_CONFIG_S_FEATURES_OK) {
+        printf(" FEATURES_OK");
+    }
+    if (status & VIRTIO_CONFIG_S_NEEDS_RESET) {
+        printf(" NEEDS_RESET");
+    }
+    if (status & VIRTIO_CONFIG_S_FAILED) {
+        printf(" FAILED");
+    }
+
+    printf("\n");
+}
+
+static inline void virtio_msg_print(VirtIOMSG *msg)
+{
+    bool resp = msg->type & VIRTIO_MSG_TYPE_RESPONSE;
+    int i;
+
+    assert(msg);
+    printf("virtio-msg: id %s 0x%x type 0x%x dev_id 0x%0x\n",
+           virtio_msg_id_to_str(msg->id), msg->id,
+           msg->type, msg->dev_id);
+
+    for (i = 0; i < 32; i++) {
+        printf("%2.2x ", msg->payload_u8[i]);
+        if (((i + 1) %  16) == 0) {
+            printf("\n");
+        }
+    }
+
+    switch (msg->id) {
+    case VIRTIO_MSG_GET_DEVICE_STATUS:
+        if (resp) {
+            virtio_msg_print_status(msg->get_device_status_resp.status);
+        }
+        break;
+    case VIRTIO_MSG_SET_DEVICE_STATUS:
+        virtio_msg_print_status(msg->set_device_status.status);
+        break;
+    case VIRTIO_MSG_SET_VQUEUE:
+        printf("set-vqueue: index=%d size=%d desc-addr=%lx driver-addr=%lx device-addr=%lx\n",
+                msg->set_vqueue.index, msg->set_vqueue.size,
+                msg->set_vqueue.descriptor_addr,
+                msg->set_vqueue.driver_addr,
+                msg->set_vqueue.device_addr);
+        break;
+    }
+    printf("\n");
+}
+
+#ifdef __XEN__
+#undef printf
+#undef assert
+#undef QEMU_PACKED
+#undef g_assert_not_reached
+#undef stringify
+#endif
+
+#endif
diff --git a/include/hw/virtio/virtio-msg-proxy-driver.h b/include/hw/virtio/virtio-msg-proxy-driver.h
new file mode 100644
index 0000000000..6addc164f8
--- /dev/null
+++ b/include/hw/virtio/virtio-msg-proxy-driver.h
@@ -0,0 +1,32 @@
+/*
+ * VirtIO MSG proxy driver.
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef QEMU_VIRTIO_MSG_PROXY_DRIVER_H
+#define QEMU_VIRTIO_MSG_PROXY_DRIVER_H
+
+#include "hw/virtio/virtio.h"
+#include "hw/virtio/virtio-msg-bus.h"
+#include "qom/object.h"
+
+#define TYPE_VIRTIO_MSG_PROXY_DRIVER "virtio-msg-proxy-driver"
+OBJECT_DECLARE_SIMPLE_TYPE(VirtIOMSGProxyDriver, VIRTIO_MSG_PROXY_DRIVER)
+#define VIRTIO_MSG_PROXY_DRIVER_GET_PARENT_CLASS(obj) \
+        OBJECT_GET_PARENT_CLASS(obj, TYPE_VIRTIO_MSG_PROXY_DRIVER)
+
+struct VirtIOMSGProxyDriver {
+    VirtIODevice parent_obj;
+
+    BusState bus;
+    VirtQueue *vq;
+
+    struct {
+        uint16_t virtio_id;
+        bool iommu_enable;
+    } cfg;
+};
+#endif
diff --git a/include/hw/virtio/virtio-msg.h b/include/hw/virtio/virtio-msg.h
new file mode 100644
index 0000000000..3d3fa91655
--- /dev/null
+++ b/include/hw/virtio/virtio-msg.h
@@ -0,0 +1,42 @@
+/*
+ * Virtio MSG bindings
+ *
+ * Copyright (c) 2024 Advanced Micro Devices, Inc.
+ * Written by Edgar E. Iglesias <edgar.iglesias@amd.com>.
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef HW_VIRTIO_MSG_PROXY_BACKEND_H
+#define HW_VIRTIO_MSG_PROXY_BACKEND_H
+
+#include "hw/sysbus.h"
+#include "hw/virtio/virtio-bus.h"
+
+#define TYPE_VIRTIO_MSG_PROXY_BUS "virtio-msg-proxy-bus"
+/* This is reusing the VirtioBusState typedef from TYPE_VIRTIO_BUS */
+DECLARE_OBJ_CHECKERS(VirtioBusState, VirtioBusClass,
+                     VIRTIO_MSG_PROXY_BUS, TYPE_VIRTIO_MSG_PROXY_BUS)
+
+#define TYPE_VIRTIO_MSG "virtio-msg"
+OBJECT_DECLARE_SIMPLE_TYPE(VirtIOMSGProxy, VIRTIO_MSG)
+
+struct VirtIOMSGProxy {
+    SysBusDevice parent_obj;
+
+    AddressSpace dma_as;
+    AddressSpace *bus_as;
+    IOMMUMemoryRegion mr_iommu;
+    MemoryRegion *mr_bus;
+
+    /* virtio-bus */
+    VirtioBusState bus;
+    /* virtio-msg-bus.  */
+    BusState msg_bus;
+
+    bool iommu_enabled;
+
+    /* Fields only used for non-legacy (v2) devices */
+    uint64_t guest_features;
+};
+#endif
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index 8b4da92889..ecf07666f7 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -183,6 +183,9 @@ struct VirtioDeviceClass {
     int (*validate_features)(VirtIODevice *vdev);
     void (*get_config)(VirtIODevice *vdev, uint8_t *config);
     void (*set_config)(VirtIODevice *vdev, const uint8_t *config);
+    uint32_t (*read_config)(VirtIODevice *vdev, int size, uint32_t addr);
+    void (*write_config)(VirtIODevice *vdev, int size, uint32_t addr,
+                         uint32_t data);
     void (*reset)(VirtIODevice *vdev);
     void (*set_status)(VirtIODevice *vdev, uint8_t val);
     /* Device must validate queue_index.  */
@@ -281,6 +284,7 @@ int virtqueue_get_avail_bytes(VirtQueue *vq, unsigned int *in_bytes,
 
 void virtio_notify_irqfd(VirtIODevice *vdev, VirtQueue *vq);
 void virtio_notify(VirtIODevice *vdev, VirtQueue *vq);
+void virtio_notify_force(VirtIODevice *vdev, VirtQueue *vq);
 
 int virtio_save(VirtIODevice *vdev, QEMUFile *f);
 
diff --git a/include/hw/xen/xen_native.h b/include/hw/xen/xen_native.h
index 1a5ad693a4..701775da29 100644
--- a/include/hw/xen/xen_native.h
+++ b/include/hw/xen/xen_native.h
@@ -547,4 +547,23 @@ static inline int xendevicemodel_set_irq_level(xendevicemodel_handle *dmod,
 #define GUEST_RAM1_SIZE   0xfe00000000ULL
 #endif
 
+/* Experimental.  */
+#ifndef XENMEM_gfn2mfn
+int xc_domain_gfn2mfn(xc_interface *xch,
+                  uint32_t domid,
+                  uint64_t gfn,
+                  uint64_t *mfn,
+                  xenmem_access_t *access);
+
+#define XENMEM_gfn2mfn                40
+struct xen_gfn2mfn {
+    domid_t domid;
+    xen_pfn_t gfn;
+    uint64_t mfn;
+    uint8_t access;
+};
+typedef struct xen_gfn2mfn xen_gfn2mfn_t;
+DEFINE_XEN_GUEST_HANDLE(xen_gfn2mfn_t);
+#endif
+
 #endif /* QEMU_HW_XEN_NATIVE_H */
diff --git a/include/qemu/iov.h b/include/qemu/iov.h
index 63a1c01965..ea8f7da381 100644
--- a/include/qemu/iov.h
+++ b/include/qemu/iov.h
@@ -20,6 +20,8 @@
  */
 size_t iov_size(const struct iovec *iov, const unsigned int iov_cnt);
 
+void *iov_memcpy(void *dest, const void *src, size_t n);
+
 /**
  * Copy from single continuous buffer to scatter-gather vector of buffers
  * (iovec) and back like memcpy() between two continuous memory regions.
@@ -43,7 +45,7 @@ iov_from_buf(const struct iovec *iov, unsigned int iov_cnt,
 {
     if (__builtin_constant_p(bytes) && iov_cnt &&
         offset <= iov[0].iov_len && bytes <= iov[0].iov_len - offset) {
-        memcpy(iov[0].iov_base + offset, buf, bytes);
+        iov_memcpy(iov[0].iov_base + offset, buf, bytes);
         return bytes;
     } else {
         return iov_from_buf_full(iov, iov_cnt, offset, buf, bytes);
@@ -56,7 +58,7 @@ iov_to_buf(const struct iovec *iov, const unsigned int iov_cnt,
 {
     if (__builtin_constant_p(bytes) && iov_cnt &&
         offset <= iov[0].iov_len && bytes <= iov[0].iov_len - offset) {
-        memcpy(buf, iov[0].iov_base + offset, bytes);
+        iov_memcpy(buf, iov[0].iov_base + offset, bytes);
         return bytes;
     } else {
         return iov_to_buf_full(iov, iov_cnt, offset, buf, bytes);
diff --git a/include/qemu/vfio-helpers.h b/include/qemu/vfio-helpers.h
index bde9495b25..ccfa11770f 100644
--- a/include/qemu/vfio-helpers.h
+++ b/include/qemu/vfio-helpers.h
@@ -28,5 +28,5 @@ void qemu_vfio_pci_unmap_bar(QEMUVFIOState *s, int index, void *bar,
                              uint64_t offset, uint64_t size);
 int qemu_vfio_pci_init_irq(QEMUVFIOState *s, EventNotifier *e,
                            int irq_type, Error **errp);
-
+void qemu_vfio_pci_unmask_irq(QEMUVFIOState *s, int irq_type);
 #endif
diff --git a/scripts/create-patch-for-za-sdk.sh b/scripts/create-patch-for-za-sdk.sh
new file mode 100755
index 0000000000..c1ae07c8a5
--- /dev/null
+++ b/scripts/create-patch-for-za-sdk.sh
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# Script to create patches for virtio-msg-demo
+#
+
+echo "Upstream-Status: Inappropriate work in progress"
+git diff v8.2.7
+
diff --git a/util/iov.c b/util/iov.c
index 7e73948f5e..fb143a423d 100644
--- a/util/iov.c
+++ b/util/iov.c
@@ -21,6 +21,48 @@
 #include "qemu/sockets.h"
 #include "qemu/cutils.h"
 
+/* memPcpy version for fully aligned copies.  */
+void *iov_fully_aligned32_mempcpy(void *d, const void *s, size_t n)
+{
+        uint32_t *d32 = d;
+        const uint32_t *s32 = s;
+
+        while (n) {
+                *d32 = *s32;
+                d32++;
+                s32++;
+                n -= 4;
+        }
+        return d32;
+}
+
+void *iov_memcpy(void *d, const void *s, size_t n)
+{
+        char l;
+        unsigned char *bd = d;
+        const unsigned char *bs = s;
+        uintptr_t pd = (unsigned long) d;
+        uintptr_t ps = (unsigned long) s;
+
+        if ((pd & 3) == 0 && (ps & 3) == 0) {
+                size_t n_aligned = n & ~3;
+
+                bd = iov_fully_aligned32_mempcpy(d, s, n_aligned);
+                if ((n & 3) == 0)
+                        return d;
+
+                /* Fix up the last chunk.  */
+                bs += n_aligned;
+                n -= n_aligned;
+        }
+
+        while (n--) {
+                l = *bs++;
+                *bd++ = l;
+        }
+        return d;
+}
+
 size_t iov_from_buf_full(const struct iovec *iov, unsigned int iov_cnt,
                          size_t offset, const void *buf, size_t bytes)
 {
@@ -29,7 +71,7 @@ size_t iov_from_buf_full(const struct iovec *iov, unsigned int iov_cnt,
     for (i = 0, done = 0; (offset || done < bytes) && i < iov_cnt; i++) {
         if (offset < iov[i].iov_len) {
             size_t len = MIN(iov[i].iov_len - offset, bytes - done);
-            memcpy(iov[i].iov_base + offset, buf + done, len);
+            iov_memcpy(iov[i].iov_base + offset, buf + done, len);
             done += len;
             offset = 0;
         } else {
@@ -48,7 +90,7 @@ size_t iov_to_buf_full(const struct iovec *iov, const unsigned int iov_cnt,
     for (i = 0, done = 0; (offset || done < bytes) && i < iov_cnt; i++) {
         if (offset < iov[i].iov_len) {
             size_t len = MIN(iov[i].iov_len - offset, bytes - done);
-            memcpy(buf + done, iov[i].iov_base + offset, len);
+            iov_memcpy(buf + done, iov[i].iov_base + offset, len);
             done += len;
             offset = 0;
         } else {
diff --git a/util/vfio-helpers.c b/util/vfio-helpers.c
index f8bab46c68..9857e73644 100644
--- a/util/vfio-helpers.c
+++ b/util/vfio-helpers.c
@@ -104,7 +104,8 @@ struct QEMUVFIOState {
  * Find group file by PCI device address as specified @device, and return the
  * path. The returned string is owned by caller and should be g_free'ed later.
  */
-static char *sysfs_find_group_file(const char *device, Error **errp)
+static char *sysfs_find_group_file(const char *device,
+                                   const char *prefix, Error **errp)
 {
     g_autoptr(GError) gerr = NULL;
     char *sysfs_link;
@@ -125,7 +126,7 @@ static char *sysfs_find_group_file(const char *device, Error **errp)
         goto out;
     }
 
-    path = g_strdup_printf("/dev/vfio/%s", p + 1);
+    path = g_strdup_printf("/dev/vfio/%s%s", prefix, p + 1);
 out:
     g_free(sysfs_link);
     g_free(sysfs_group);
@@ -190,6 +191,19 @@ void qemu_vfio_pci_unmap_bar(QEMUVFIOState *s, int index, void *bar,
     }
 }
 
+void qemu_vfio_pci_unmask_irq(QEMUVFIOState *s, int irq_type)
+{
+    struct vfio_irq_set irq_set = {
+        .argsz = sizeof(irq_set),
+        .flags = VFIO_IRQ_SET_DATA_NONE | VFIO_IRQ_SET_ACTION_UNMASK,
+        .index = irq_type,
+        .start = 0,
+        .count = 1,
+    };
+
+    ioctl(s->device, VFIO_DEVICE_SET_IRQS, &irq_set);
+}
+
 /**
  * Initialize device IRQ with @irq_type and register an event notifier.
  */
@@ -301,7 +315,9 @@ static int qemu_vfio_init_pci(QEMUVFIOState *s, const char *device,
     struct vfio_iommu_type1_info *iommu_info = NULL;
     size_t iommu_info_size = sizeof(*iommu_info);
     struct vfio_device_info device_info = { .argsz = sizeof(device_info) };
+    int iommu_model = VFIO_TYPE1_IOMMU;
     char *group_file = NULL;
+    bool has_iommu = true;
 
     s->usable_iova_ranges = NULL;
 
@@ -325,13 +341,27 @@ static int qemu_vfio_init_pci(QEMUVFIOState *s, const char *device,
     }
 
     /* Open the group */
-    group_file = sysfs_find_group_file(device, errp);
+    group_file = sysfs_find_group_file(device, "", errp);
     if (!group_file) {
         ret = -EINVAL;
         goto fail_container;
     }
 
     s->group = open(group_file, O_RDWR);
+    if (s->group == -1) {
+        /* Try again without IOMMU.  */
+        has_iommu = false;
+        g_free(group_file);
+        iommu_model = VFIO_NOIOMMU_IOMMU;
+        group_file = sysfs_find_group_file(device, "noiommu-", errp);
+        if (!group_file) {
+            ret = -EINVAL;
+            goto fail_container;
+        }
+
+        s->group = open(group_file, O_RDWR);
+    }
+
     if (s->group == -1) {
         error_setg_errno(errp, errno, "Failed to open VFIO group file: %s",
                          group_file);
@@ -362,7 +392,7 @@ static int qemu_vfio_init_pci(QEMUVFIOState *s, const char *device,
     }
 
     /* Enable the IOMMU model we want */
-    if (ioctl(s->container, VFIO_SET_IOMMU, VFIO_TYPE1_IOMMU)) {
+    if (ioctl(s->container, VFIO_SET_IOMMU, iommu_model)) {
         error_setg_errno(errp, errno, "Failed to set VFIO IOMMU type");
         ret = -errno;
         goto fail;
@@ -372,7 +402,7 @@ static int qemu_vfio_init_pci(QEMUVFIOState *s, const char *device,
     iommu_info->argsz = iommu_info_size;
 
     /* Get additional IOMMU info */
-    if (ioctl(s->container, VFIO_IOMMU_GET_INFO, iommu_info)) {
+    if (has_iommu && ioctl(s->container, VFIO_IOMMU_GET_INFO, iommu_info)) {
         error_setg_errno(errp, errno, "Failed to get IOMMU info");
         ret = -errno;
         goto fail;
@@ -438,15 +468,19 @@ static int qemu_vfio_init_pci(QEMUVFIOState *s, const char *device,
         }
     }
 
-    /* Enable bus master */
-    ret = qemu_vfio_pci_read_config(s, &pci_cmd, sizeof(pci_cmd), PCI_COMMAND);
-    if (ret) {
-        goto fail;
-    }
-    pci_cmd |= PCI_COMMAND_MASTER;
-    ret = qemu_vfio_pci_write_config(s, &pci_cmd, sizeof(pci_cmd), PCI_COMMAND);
-    if (ret) {
-        goto fail;
+    /* Enable bus master only if the device is behind an IOMMU. */
+    if (has_iommu || 1) {
+        ret = qemu_vfio_pci_read_config(s, &pci_cmd, sizeof(pci_cmd),
+                                        PCI_COMMAND);
+        if (ret) {
+            goto fail;
+        }
+        pci_cmd |= PCI_COMMAND_MASTER;
+        ret = qemu_vfio_pci_write_config(s, &pci_cmd, sizeof(pci_cmd),
+                                         PCI_COMMAND);
+        if (ret) {
+            goto fail;
+        }
     }
     g_free(iommu_info);
     return 0;
